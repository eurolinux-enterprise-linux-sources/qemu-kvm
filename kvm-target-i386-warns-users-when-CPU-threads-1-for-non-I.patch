From 7aa50ad5e8bc0bd1423578415c7f78d06e1989a6 Mon Sep 17 00:00:00 2001
Message-Id: <7aa50ad5e8bc0bd1423578415c7f78d06e1989a6.1477598874.git.ymankad@redhat.com>
In-Reply-To: <ddf5944bcc06f57d62aac4d33075fb5b1eb1cb22.1477598874.git.ymankad@redhat.com>
References: <ddf5944bcc06f57d62aac4d33075fb5b1eb1cb22.1477598874.git.ymankad@redhat.com>
From: Wei Huang <wei@redhat.com>
Date: Thu, 13 Oct 2016 18:24:36 -0400
Subject: [CHANGE 3/3] target-i386: warns users when CPU threads>1 for
 non-Intel CPUs
To: rhvirt-patches@redhat.com,
    ymankad@redhat.com

RH-Author: Wei Huang <wei@redhat.com>
Message-id: <1476383076-13327-1-git-send-email-wei@redhat.com>
Patchwork-id: 72512
O-Subject: [RHEL-6.9 qemu-kvm PATCH 1/1] target-i386: warns users when CPU threads>1 for non-Intel CPUs
Bugzilla: 1292678 1320066
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>
RH-Acked-by: Eduardo Habkost <ehabkost@redhat.com>
RH-Acked-by: Thomas Huth <thuth@redhat.com>

BZ: 1292678, 1320066
Brew: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=11905738
Upstream: commit e48638fd, modified

Only Intel CPUs support hyperthreading. When users select threads>1 in
-smp option, QEMU fixes it by adjusting CPUID_0000_0001_EBX and
CPUID_8000_0008_ECX based on inputs (sockets, cores, threads);
so guest VM can boot correctly. However it is still better to gives
users a warning when such case happens. Upstream QEMU solved this
problem in commit e48638fd.

This patch is a re-implementation based on the upstream QEMU commit
e48638fd. It is different from e48638fd because env->cpuid_vendorX
in this version of QEMU never gets updated like newer QEMU does. So,
instead of relying on env->cpuid_vendorX, this patch calls cpu_x86_cpuid()
to retrive accurate CPU vendor info.

Signed-off-by: Wei Huang <wei@redhat.com>
Signed-off-by: Yash Mankad <ymankad@redhat.com>
---
 hw/pc.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/hw/pc.c b/hw/pc.c
index 349d218..644edff 100644
--- a/hw/pc.c
+++ b/hw/pc.c
@@ -1047,9 +1047,27 @@ int cpu_is_bsp(CPUState *env)
     return env->cpuid_apic_id == 0;
 }
 
+static bool x86_cpu_is_intel(CPUState *env)
+{
+    uint32_t eax, ebx, ecx, edx;
+
+    /* Instead of relying env->cpuid_vendorX, check target cpuid function 0
+     * for accurate CPU vendor info.
+     */
+    cpu_x86_cpuid(env, 0, 0, &eax, &ebx, &ecx, &edx);
+
+    if (ebx == CPUID_VENDOR_INTEL_1 && edx == CPUID_VENDOR_INTEL_2 &&
+        ecx == CPUID_VENDOR_INTEL_3) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
 CPUState *pc_new_cpu(const char *cpu_model)
 {
     CPUState *env;
+    static bool ht_warned;
 
     if (runstate_is_running()) {
         pause_all_vcpus();
@@ -1075,6 +1093,20 @@ CPUState *pc_new_cpu(const char *cpu_model)
      */
     qemu_init_vcpu(env);
 
+    /* Only Intel CPUs support hyperthreading. Even though QEMU fixes this
+     * issue by adjusting CPUID_0000_0001_EBX and CPUID_8000_0008_ECX
+     * based on inputs (sockets,cores,threads), it is still better to gives
+     * users a warning.
+     *
+     * NOTE: the following code has to follow qemu_init_vcpu(). Otherwise
+     * cs->nr_threads hasn't be populated yet and the checking is incorrect.
+     */
+    if (!x86_cpu_is_intel(env) && env->nr_threads > 1 && !ht_warned) {
+        error_report("AMD CPU doesn't support hyperthreading. Please configure"
+                     " -smp options properly.");
+        ht_warned = true;
+    }
+
     if (runstate_is_running()) {
         resume_all_vcpus();
     }
-- 
2.7.4

