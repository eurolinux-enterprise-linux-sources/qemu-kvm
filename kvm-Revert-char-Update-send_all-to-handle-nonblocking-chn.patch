From 0a69e1f5d57cf4033456948ec30e247453ee6f59 Mon Sep 17 00:00:00 2001
Message-Id: <0a69e1f5d57cf4033456948ec30e247453ee6f59.1368111913.git.minovotn@redhat.com>
In-Reply-To: <405603258af5154387bea676be1f904b6713f6ae.1368111913.git.minovotn@redhat.com>
References: <405603258af5154387bea676be1f904b6713f6ae.1368111913.git.minovotn@redhat.com>
From: Amit Shah <amit.shah@redhat.com>
Date: Wed, 24 Apr 2013 08:17:41 +0200
Subject: [PATCH 07/65] Revert "char: Update send_all() to handle nonblocking
 chardev write requests"

RH-Author: Amit Shah <amit.shah@redhat.com>
Message-id: <1ed4c53bb563fc1e4e8775d9e2012ab5c55380ee.1366724981.git.amit.shah@redhat.com>
Patchwork-id: 50785
O-Subject: [RHEL6.5 qemu-kvm PATCH 07/65] Revert "char: Update send_all() to handle nonblocking chardev write requests"
Bugzilla: 909059
RH-Acked-by: Hans de Goede <hdegoede@redhat.com>
RH-Acked-by: Gerd Hoffmann <kraxel@redhat.com>
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>

This reverts commit 72f2daa85a6521892c66201fe62aa5c012a43fb3.

Signed-off-by: Amit Shah <amit.shah@redhat.com>
---
 net/socket.c  |  4 ++--
 qemu-char.c   | 73 +++++------------------------------------------------------
 qemu_socket.h |  2 +-
 3 files changed, 9 insertions(+), 70 deletions(-)

Signed-off-by: Michal Novotny <minovotn@redhat.com>
---
 net/socket.c  |  4 ++--
 qemu-char.c   | 73 +++++------------------------------------------------------
 qemu_socket.h |  2 +-
 3 files changed, 9 insertions(+), 70 deletions(-)

diff --git a/net/socket.c b/net/socket.c
index 902529e..1c4e153 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -56,8 +56,8 @@ static ssize_t net_socket_receive(VLANClientState *nc, const uint8_t *buf, size_
     uint32_t len;
     len = htonl(size);
 
-    send_all(NULL, s->fd, (const uint8_t *)&len, sizeof(len));
-    return send_all(NULL, s->fd, buf, size);
+    send_all(s->fd, (const uint8_t *)&len, sizeof(len));
+    return send_all(s->fd, buf, size);
 }
 
 static ssize_t net_socket_receive_dgram(VLANClientState *nc, const uint8_t *buf, size_t size)
diff --git a/qemu-char.c b/qemu-char.c
index df0025d..d1ddcfc 100644
--- a/qemu-char.c
+++ b/qemu-char.c
@@ -517,7 +517,7 @@ static CharDriverState *qemu_chr_open_mux(CharDriverState *drv)
 
 
 #ifdef _WIN32
-static int do_send(int fd, const void *buf, int len1, bool nonblock)
+int send_all(int fd, const void *buf, int len1)
 {
     int ret, len;
 
@@ -525,14 +525,9 @@ static int do_send(int fd, const void *buf, int len1, bool nonblock)
     while (len > 0) {
         ret = send(fd, buf, len, 0);
         if (ret < 0) {
-            if (nonblock && len1 - len) {
-                return len1 - len;
-            }
             errno = WSAGetLastError();
             if (errno != WSAEWOULDBLOCK) {
                 return -1;
-            } else if (errno == WSAEWOULDBLOCK && nonblock) {
-                return WSAEWOULDBLOCK;
             }
         } else if (ret == 0) {
             break;
@@ -546,7 +541,7 @@ static int do_send(int fd, const void *buf, int len1, bool nonblock)
 
 #else
 
-static int do_send(int fd, const void *_buf, int len1, bool nonblock)
+int send_all(int fd, const void *_buf, int len1)
 {
     int ret, len;
     const uint8_t *buf = _buf;
@@ -555,15 +550,8 @@ static int do_send(int fd, const void *_buf, int len1, bool nonblock)
     while (len > 0) {
         ret = write(fd, buf, len);
         if (ret < 0) {
-            if (nonblock && len1 - len) {
-                return len1 - len;
-            }
-            if (errno == EAGAIN && nonblock) {
-                return -EAGAIN;
-            }
-            if (errno != EINTR && errno != EAGAIN) {
+            if (errno != EINTR && errno != EAGAIN)
                 return -1;
-            }
         } else if (ret == 0) {
             break;
         } else {
@@ -575,55 +563,6 @@ static int do_send(int fd, const void *_buf, int len1, bool nonblock)
 }
 #endif /* !_WIN32 */
 
-int send_all(CharDriverState *chr, int fd, const void *_buf, int len1)
-{
-    int ret, eagain_errno;
-    bool nonblock;
-
-    if (chr && chr->write_blocked) {
-        /*
-         * We don't handle this situation: the caller should not send
-         * us data while we're blocked.
-         *
-         * We could buffer this data here but that'll only encourage
-         * bad behaviour on part of the callers.
-         *
-         * Also, the data already in fd's buffers isn't easily
-         * migratable.  If we want full migration support, all the
-         * data landing here needs to be buffered and on migration,
-         * anything that's unsent needs to be transferred to the
-         * dest. machine (which again isn't a very good way of solving
-         * the problem, as the src may become writable just during
-         * migration and the reader could receive some data twice,
-         * essentially corrupting the data).
-         */
-        abort();
-    }
-
-    nonblock = false;
-    /*
-     * Ensure the char backend is able to receive and handle the
-     * 'write unblocked' event before we turn on nonblock support.
-     */
-    if (chr && chr->chr_enable_write_fd_handler && chr->chr_write_unblocked) {
-        nonblock = true;
-    }
-    ret = do_send(fd, _buf, len1, nonblock);
-
-#ifdef _WIN32
-    eagain_errno = WSAEWOULDBLOCK;
-#else
-    eagain_errno = -EAGAIN;
-#endif
-
-    if (nonblock && (ret == eagain_errno || (ret >= 0 && ret < len1))) {
-        /* Update fd handler to wake up when chr becomes writable */
-        chr->chr_enable_write_fd_handler(chr);
-        chr->write_blocked = true;
-    }
-    return ret;
-}
-
 #ifndef _WIN32
 
 typedef struct {
@@ -637,7 +576,7 @@ static int stdio_nb_clients = 0;
 static int fd_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
 {
     FDCharDriver *s = chr->opaque;
-    return send_all(chr, s->fd_out, buf, len);
+    return send_all(s->fd_out, buf, len);
 }
 
 static int fd_chr_read_poll(void *opaque)
@@ -953,7 +892,7 @@ static int pty_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
         pty_chr_update_read_handler(chr);
         return 0;
     }
-    return send_all(chr, s->fd, buf, len);
+    return send_all(s->fd, buf, len);
 }
 
 static int pty_chr_read_poll(void *opaque)
@@ -2026,7 +1965,7 @@ static int tcp_chr_write(CharDriverState *chr, const uint8_t *buf, int len)
     if (s->connected) {
         int ret;
 
-        ret = send_all(chr, s->fd, buf, len);
+        ret = send_all(s->fd, buf, len);
         if (ret == -1 && errno == EPIPE) {
             tcp_closed(chr);
         }
diff --git a/qemu_socket.h b/qemu_socket.h
index bb439d1..3c2caff 100644
--- a/qemu_socket.h
+++ b/qemu_socket.h
@@ -37,7 +37,7 @@ int inet_aton(const char *cp, struct in_addr *ia);
 int qemu_socket(int domain, int type, int protocol);
 int qemu_accept(int s, struct sockaddr *addr, socklen_t *addrlen);
 void socket_set_nonblock(int fd);
-int send_all(CharDriverState *chr, int fd, const void *buf, int len1);
+int send_all(int fd, const void *buf, int len1);
 
 /* callback function for nonblocking connect
  * valid fd on success, negative error code on failure
-- 
1.7.11.7

