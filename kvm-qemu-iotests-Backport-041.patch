From 70d02595c87c0c134c77e07f0740eac9234ed61b Mon Sep 17 00:00:00 2001
From: Kevin Wolf <kwolf@redhat.com>
Date: Thu, 31 Jul 2014 16:03:46 -0500
Subject: [CHANGE 24/31] qemu-iotests: Backport 041
To: rhvirt-patches@redhat.com,
    jen@redhat.com

RH-Author: Kevin Wolf <kwolf@redhat.com>
Message-id: <1406822631-6570-25-git-send-email-kwolf@redhat.com>
Patchwork-id: 60385
O-Subject: [RHEL-6.6 qemu-kvm PATCH v3 24/29] qemu-iotests: Backport 041
Bugzilla: 1122410
RH-Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
RH-Acked-by: Jeffrey Cody <jcody@redhat.com>
RH-Acked-by: Max Reitz <mreitz@redhat.com>

The test needs the following adjustments for RHEL 6:

* Remove quorum tests, RHEL 6 doesn't have that driver

* No event when a block job is ready. Replace by polling.

* __com.redhat_drive-mirror and __com.redhat_drive-reopen downstream
  extensions instead of upstream drive-mirror and block-job-complete

* No support for pausing block jobs, on-error and buf-size, remove test
  cases

* sync=full/top is full=true/false, sync=none isn't supported

Signed-off-by: Kevin Wolf <kwolf@redhat.com>
Signed-off-by: jen <jen@redhat.com>
---
 tests/qemu-iotests/041     | 647 +++------------------------------------------
 tests/qemu-iotests/041.out |   4 +-
 2 files changed, 40 insertions(+), 611 deletions(-)

diff --git a/tests/qemu-iotests/041 b/tests/qemu-iotests/041
index 5dbd4ee..160d46a 100755
--- a/tests/qemu-iotests/041
+++ b/tests/qemu-iotests/041
@@ -21,6 +21,7 @@
 import time
 import os
 import iotests
+import traceback
 from iotests import qemu_img, qemu_io
 
 backing_img = os.path.join(iotests.test_dir, 'backing.img')
@@ -28,12 +29,6 @@ target_backing_img = os.path.join(iotests.test_dir, 'target-backing.img')
 test_img = os.path.join(iotests.test_dir, 'test.img')
 target_img = os.path.join(iotests.test_dir, 'target.img')
 
-quorum_img1 = os.path.join(iotests.test_dir, 'quorum1.img')
-quorum_img2 = os.path.join(iotests.test_dir, 'quorum2.img')
-quorum_img3 = os.path.join(iotests.test_dir, 'quorum3.img')
-quorum_repair_img = os.path.join(iotests.test_dir, 'quorum_repair.img')
-quorum_snapshot_file = os.path.join(iotests.test_dir, 'quorum_snapshot.img')
-
 class ImageMirroringTestCase(iotests.QMPTestCase):
     '''Abstract base class for image mirroring test cases'''
 
@@ -41,15 +36,15 @@ class ImageMirroringTestCase(iotests.QMPTestCase):
         '''Wait until a block job BLOCK_JOB_READY event'''
         ready = False
         while not ready:
-            for event in self.vm.get_qmp_events(wait=True):
-                if event['event'] == 'BLOCK_JOB_READY':
-                    self.assert_qmp(event, 'data/type', 'mirror')
-                    self.assert_qmp(event, 'data/device', drive)
-                    ready = True
+            result = self.vm.qmp('query-block-jobs')
+            if result['return'][0]['len'] == result['return'][0]['offset']:
+                ready = True
+            else:
+                time.sleep(1)
 
     def wait_ready_and_cancel(self, drive='drive0'):
-        self.wait_ready(drive=drive)
-        event = self.cancel_and_wait(drive=drive)
+        self.wait_ready(drive)
+        event = self.cancel_and_wait()
         self.assertEquals(event['event'], 'BLOCK_JOB_COMPLETED')
         self.assert_qmp(event, 'data/type', 'mirror')
         self.assert_qmp(event, 'data/offset', self.image_len)
@@ -58,12 +53,12 @@ class ImageMirroringTestCase(iotests.QMPTestCase):
     def complete_and_wait(self, drive='drive0', wait_ready=True):
         '''Complete a block job and wait for it to finish'''
         if wait_ready:
-            self.wait_ready(drive=drive)
+            self.wait_ready()
 
-        result = self.vm.qmp('block-job-complete', device=drive)
+        result = self.vm.qmp('__com.redhat_drive-reopen', device=drive, new_image_file=target_img)
         self.assert_qmp(result, 'return', {})
 
-        event = self.wait_until_completed(drive=drive)
+        event = self.wait_until_completed()
         self.assert_qmp(event, 'data/type', 'mirror')
 
 class TestSingleDrive(ImageMirroringTestCase):
@@ -87,7 +82,7 @@ class TestSingleDrive(ImageMirroringTestCase):
     def test_complete(self):
         self.assert_no_active_block_jobs()
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -101,11 +96,13 @@ class TestSingleDrive(ImageMirroringTestCase):
     def test_cancel(self):
         self.assert_no_active_block_jobs()
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              target=target_img)
         self.assert_qmp(result, 'return', {})
 
-        self.cancel_and_wait(force=True)
+        # RHEL 6 doesn't have a force option
+        #self.cancel_and_wait(force=True)
+        self.cancel_and_wait()
         result = self.vm.qmp('query-block')
         self.assert_qmp(result, 'return[0]/inserted/file', test_img)
         self.vm.shutdown()
@@ -113,7 +110,7 @@ class TestSingleDrive(ImageMirroringTestCase):
     def test_cancel_after_ready(self):
         self.assert_no_active_block_jobs()
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -124,69 +121,12 @@ class TestSingleDrive(ImageMirroringTestCase):
         self.assertTrue(iotests.compare_images(test_img, target_img),
                         'target image does not match source after mirroring')
 
-    def test_pause(self):
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             target=target_img)
-        self.assert_qmp(result, 'return', {})
-
-        result = self.vm.qmp('block-job-pause', device='drive0')
-        self.assert_qmp(result, 'return', {})
-
-        time.sleep(1)
-        result = self.vm.qmp('query-block-jobs')
-        offset = self.dictpath(result, 'return[0]/offset')
-
-        time.sleep(1)
-        result = self.vm.qmp('query-block-jobs')
-        self.assert_qmp(result, 'return[0]/offset', offset)
-
-        result = self.vm.qmp('block-job-resume', device='drive0')
-        self.assert_qmp(result, 'return', {})
-
-        self.complete_and_wait()
-        self.vm.shutdown()
-        self.assertTrue(iotests.compare_images(test_img, target_img),
-                        'target image does not match source after mirroring')
-
-    def test_small_buffer(self):
-        self.assert_no_active_block_jobs()
-
-        # A small buffer is rounded up automatically
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             buf_size=4096, target=target_img)
-        self.assert_qmp(result, 'return', {})
-
-        self.complete_and_wait()
-        result = self.vm.qmp('query-block')
-        self.assert_qmp(result, 'return[0]/inserted/file', target_img)
-        self.vm.shutdown()
-        self.assertTrue(iotests.compare_images(test_img, target_img),
-                        'target image does not match source after mirroring')
-
-    def test_small_buffer2(self):
-        self.assert_no_active_block_jobs()
-
-        qemu_img('create', '-f', iotests.imgfmt, '-o', 'cluster_size=%d,size=%d'
-                        % (self.image_len, self.image_len), target_img)
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             buf_size=65536, mode='existing', target=target_img)
-        self.assert_qmp(result, 'return', {})
-
-        self.complete_and_wait()
-        result = self.vm.qmp('query-block')
-        self.assert_qmp(result, 'return[0]/inserted/file', target_img)
-        self.vm.shutdown()
-        self.assertTrue(iotests.compare_images(test_img, target_img),
-                        'target image does not match source after mirroring')
-
     def test_large_cluster(self):
         self.assert_no_active_block_jobs()
 
         qemu_img('create', '-f', iotests.imgfmt, '-o', 'cluster_size=%d,backing_file=%s'
                         % (self.image_len, backing_img), target_img)
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              mode='existing', target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -198,17 +138,17 @@ class TestSingleDrive(ImageMirroringTestCase):
                         'target image does not match source after mirroring')
 
     def test_medium_not_found(self):
-        result = self.vm.qmp('drive-mirror', device='ide1-cd0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='ide1-cd0',
                              target=target_img)
-        self.assert_qmp(result, 'error/class', 'GenericError')
+        self.assert_qmp(result, 'error/class', 'DeviceHasNoMedium')
 
     def test_image_not_found(self):
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              mode='existing', target=target_img)
-        self.assert_qmp(result, 'error/class', 'GenericError')
+        self.assert_qmp(result, 'error/class', 'OpenFileFailed')
 
     def test_device_not_found(self):
-        result = self.vm.qmp('drive-mirror', device='nonexistent', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='nonexistent',
                              target=target_img)
         self.assert_qmp(result, 'error/class', 'DeviceNotFound')
 
@@ -250,7 +190,7 @@ class TestMirrorNoBacking(ImageMirroringTestCase):
         self.assert_no_active_block_jobs()
 
         qemu_img('create', '-f', iotests.imgfmt, '-o', 'backing_file=%s' % backing_img, target_img)
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              mode='existing', target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -263,9 +203,8 @@ class TestMirrorNoBacking(ImageMirroringTestCase):
 
     def test_cancel(self):
         self.assert_no_active_block_jobs()
-
         qemu_img('create', '-f', iotests.imgfmt, '-o', 'backing_file=%s' % backing_img, target_img)
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              mode='existing', target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -286,7 +225,7 @@ class TestMirrorNoBacking(ImageMirroringTestCase):
                         % (TestMirrorNoBacking.image_len, target_backing_img), target_img)
         os.remove(target_backing_img)
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              mode='existing', target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -320,7 +259,7 @@ class TestMirrorResized(ImageMirroringTestCase):
     def test_complete_top(self):
         self.assert_no_active_block_jobs()
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='top',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0', full=False,
                              target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -334,7 +273,7 @@ class TestMirrorResized(ImageMirroringTestCase):
     def test_complete_full(self):
         self.assert_no_active_block_jobs()
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0', full=True,
                              target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -345,288 +284,6 @@ class TestMirrorResized(ImageMirroringTestCase):
         self.assertTrue(iotests.compare_images(test_img, target_img),
                         'target image does not match source after mirroring')
 
-class TestReadErrors(ImageMirroringTestCase):
-    image_len = 2 * 1024 * 1024 # MB
-
-    # this should be a multiple of twice the default granularity
-    # so that we hit this offset first in state 1
-    MIRROR_GRANULARITY = 1024 * 1024
-
-    def create_blkdebug_file(self, name, event, errno):
-        file = open(name, 'w')
-        file.write('''
-[inject-error]
-state = "1"
-event = "%s"
-errno = "%d"
-immediately = "off"
-once = "on"
-sector = "%d"
-
-[set-state]
-state = "1"
-event = "%s"
-new_state = "2"
-
-[set-state]
-state = "2"
-event = "%s"
-new_state = "1"
-''' % (event, errno, self.MIRROR_GRANULARITY / 512, event, event))
-        file.close()
-
-    def setUp(self):
-        self.blkdebug_file = backing_img + ".blkdebug"
-        iotests.create_image(backing_img, TestReadErrors.image_len)
-        self.create_blkdebug_file(self.blkdebug_file, "read_aio", 5)
-        qemu_img('create', '-f', iotests.imgfmt,
-                 '-o', 'backing_file=blkdebug:%s:%s,backing_fmt=raw'
-                       % (self.blkdebug_file, backing_img),
-                 test_img)
-        # Write something for tests that use sync='top'
-        qemu_io('-c', 'write %d 512' % (self.MIRROR_GRANULARITY + 65536),
-                        test_img)
-        self.vm = iotests.VM().add_drive(test_img)
-        self.vm.launch()
-
-    def tearDown(self):
-        self.vm.shutdown()
-        os.remove(test_img)
-        os.remove(backing_img)
-        os.remove(self.blkdebug_file)
-
-    def test_report_read(self):
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             target=target_img)
-        self.assert_qmp(result, 'return', {})
-
-        completed = False
-        error = False
-        while not completed:
-            for event in self.vm.get_qmp_events(wait=True):
-                if event['event'] == 'BLOCK_JOB_ERROR':
-                    self.assert_qmp(event, 'data/device', 'drive0')
-                    self.assert_qmp(event, 'data/operation', 'read')
-                    error = True
-                elif event['event'] == 'BLOCK_JOB_READY':
-                    self.assertTrue(False, 'job completed unexpectedly')
-                elif event['event'] == 'BLOCK_JOB_COMPLETED':
-                    self.assertTrue(error, 'job completed unexpectedly')
-                    self.assert_qmp(event, 'data/type', 'mirror')
-                    self.assert_qmp(event, 'data/device', 'drive0')
-                    self.assert_qmp(event, 'data/error', 'Input/output error')
-                    self.assert_qmp(event, 'data/len', self.image_len)
-                    completed = True
-
-        self.assert_no_active_block_jobs()
-        self.vm.shutdown()
-
-    def test_ignore_read(self):
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             target=target_img, on_source_error='ignore')
-        self.assert_qmp(result, 'return', {})
-
-        event = self.vm.get_qmp_event(wait=True)
-        self.assertEquals(event['event'], 'BLOCK_JOB_ERROR')
-        self.assert_qmp(event, 'data/device', 'drive0')
-        self.assert_qmp(event, 'data/operation', 'read')
-        result = self.vm.qmp('query-block-jobs')
-        self.assert_qmp(result, 'return[0]/paused', False)
-        self.complete_and_wait()
-        self.vm.shutdown()
-
-    def test_large_cluster(self):
-        self.assert_no_active_block_jobs()
-
-        # Test COW into the target image.  The first half of the
-        # cluster at MIRROR_GRANULARITY has to be copied from
-        # backing_img, even though sync='top'.
-        qemu_img('create', '-f', iotests.imgfmt, '-ocluster_size=131072,backing_file=%s' %(backing_img), target_img)
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='top',
-                             on_source_error='ignore',
-                             mode='existing', target=target_img)
-        self.assert_qmp(result, 'return', {})
-
-        event = self.vm.get_qmp_event(wait=True)
-        self.assertEquals(event['event'], 'BLOCK_JOB_ERROR')
-        self.assert_qmp(event, 'data/device', 'drive0')
-        self.assert_qmp(event, 'data/operation', 'read')
-        result = self.vm.qmp('query-block-jobs')
-        self.assert_qmp(result, 'return[0]/paused', False)
-        self.complete_and_wait()
-        self.vm.shutdown()
-
-        # Detach blkdebug to compare images successfully
-        qemu_img('rebase', '-f', iotests.imgfmt, '-u', '-b', backing_img, test_img)
-        self.assertTrue(iotests.compare_images(test_img, target_img),
-                        'target image does not match source after mirroring')
-
-    def test_stop_read(self):
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             target=target_img, on_source_error='stop')
-        self.assert_qmp(result, 'return', {})
-
-        error = False
-        ready = False
-        while not ready:
-            for event in self.vm.get_qmp_events(wait=True):
-                if event['event'] == 'BLOCK_JOB_ERROR':
-                    self.assert_qmp(event, 'data/device', 'drive0')
-                    self.assert_qmp(event, 'data/operation', 'read')
-
-                    result = self.vm.qmp('query-block-jobs')
-                    self.assert_qmp(result, 'return[0]/paused', True)
-                    self.assert_qmp(result, 'return[0]/io-status', 'failed')
-
-                    result = self.vm.qmp('block-job-resume', device='drive0')
-                    self.assert_qmp(result, 'return', {})
-                    error = True
-                elif event['event'] == 'BLOCK_JOB_READY':
-                    self.assertTrue(error, 'job completed unexpectedly')
-                    self.assert_qmp(event, 'data/device', 'drive0')
-                    ready = True
-
-        result = self.vm.qmp('query-block-jobs')
-        self.assert_qmp(result, 'return[0]/paused', False)
-        self.assert_qmp(result, 'return[0]/io-status', 'ok')
-
-        self.complete_and_wait(wait_ready=False)
-        self.assert_no_active_block_jobs()
-        self.vm.shutdown()
-
-class TestWriteErrors(ImageMirroringTestCase):
-    image_len = 2 * 1024 * 1024 # MB
-
-    # this should be a multiple of twice the default granularity
-    # so that we hit this offset first in state 1
-    MIRROR_GRANULARITY = 1024 * 1024
-
-    def create_blkdebug_file(self, name, event, errno):
-        file = open(name, 'w')
-        file.write('''
-[inject-error]
-state = "1"
-event = "%s"
-errno = "%d"
-immediately = "off"
-once = "on"
-sector = "%d"
-
-[set-state]
-state = "1"
-event = "%s"
-new_state = "2"
-
-[set-state]
-state = "2"
-event = "%s"
-new_state = "1"
-''' % (event, errno, self.MIRROR_GRANULARITY / 512, event, event))
-        file.close()
-
-    def setUp(self):
-        self.blkdebug_file = target_img + ".blkdebug"
-        iotests.create_image(backing_img, TestWriteErrors.image_len)
-        self.create_blkdebug_file(self.blkdebug_file, "write_aio", 5)
-        qemu_img('create', '-f', iotests.imgfmt, '-obacking_file=%s' %(backing_img), test_img)
-        self.vm = iotests.VM().add_drive(test_img)
-        self.target_img = 'blkdebug:%s:%s' % (self.blkdebug_file, target_img)
-        qemu_img('create', '-f', iotests.imgfmt, '-osize=%d' %(TestWriteErrors.image_len), target_img)
-        self.vm.launch()
-
-    def tearDown(self):
-        self.vm.shutdown()
-        os.remove(test_img)
-        os.remove(backing_img)
-        os.remove(self.blkdebug_file)
-
-    def test_report_write(self):
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             mode='existing', target=self.target_img)
-        self.assert_qmp(result, 'return', {})
-
-        completed = False
-        error = False
-        while not completed:
-            for event in self.vm.get_qmp_events(wait=True):
-                if event['event'] == 'BLOCK_JOB_ERROR':
-                    self.assert_qmp(event, 'data/device', 'drive0')
-                    self.assert_qmp(event, 'data/operation', 'write')
-                    error = True
-                elif event['event'] == 'BLOCK_JOB_READY':
-                    self.assertTrue(False, 'job completed unexpectedly')
-                elif event['event'] == 'BLOCK_JOB_COMPLETED':
-                    self.assertTrue(error, 'job completed unexpectedly')
-                    self.assert_qmp(event, 'data/type', 'mirror')
-                    self.assert_qmp(event, 'data/device', 'drive0')
-                    self.assert_qmp(event, 'data/error', 'Input/output error')
-                    self.assert_qmp(event, 'data/len', self.image_len)
-                    completed = True
-
-        self.assert_no_active_block_jobs()
-        self.vm.shutdown()
-
-    def test_ignore_write(self):
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             mode='existing', target=self.target_img,
-                             on_target_error='ignore')
-        self.assert_qmp(result, 'return', {})
-
-        event = self.vm.get_qmp_event(wait=True)
-        self.assertEquals(event['event'], 'BLOCK_JOB_ERROR')
-        self.assert_qmp(event, 'data/device', 'drive0')
-        self.assert_qmp(event, 'data/operation', 'write')
-        result = self.vm.qmp('query-block-jobs')
-        self.assert_qmp(result, 'return[0]/paused', False)
-        self.complete_and_wait()
-        self.vm.shutdown()
-
-    def test_stop_write(self):
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
-                             mode='existing', target=self.target_img,
-                             on_target_error='stop')
-        self.assert_qmp(result, 'return', {})
-
-        error = False
-        ready = False
-        while not ready:
-            for event in self.vm.get_qmp_events(wait=True):
-                if event['event'] == 'BLOCK_JOB_ERROR':
-                    self.assert_qmp(event, 'data/device', 'drive0')
-                    self.assert_qmp(event, 'data/operation', 'write')
-
-                    result = self.vm.qmp('query-block-jobs')
-                    self.assert_qmp(result, 'return[0]/paused', True)
-                    self.assert_qmp(result, 'return[0]/io-status', 'failed')
-
-                    result = self.vm.qmp('block-job-resume', device='drive0')
-                    self.assert_qmp(result, 'return', {})
-
-                    result = self.vm.qmp('query-block-jobs')
-                    self.assert_qmp(result, 'return[0]/paused', False)
-                    self.assert_qmp(result, 'return[0]/io-status', 'ok')
-                    error = True
-                elif event['event'] == 'BLOCK_JOB_READY':
-                    self.assertTrue(error, 'job completed unexpectedly')
-                    self.assert_qmp(event, 'data/device', 'drive0')
-                    ready = True
-
-        self.complete_and_wait(wait_ready=False)
-        self.assert_no_active_block_jobs()
-        self.vm.shutdown()
-
 class TestSetSpeed(ImageMirroringTestCase):
     image_len = 80 * 1024 * 1024 # MB
 
@@ -645,7 +302,7 @@ class TestSetSpeed(ImageMirroringTestCase):
     def test_set_speed(self):
         self.assert_no_active_block_jobs()
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              target=target_img)
         self.assert_qmp(result, 'return', {})
 
@@ -665,7 +322,7 @@ class TestSetSpeed(ImageMirroringTestCase):
         self.wait_ready_and_cancel()
 
         # Check setting speed in drive-mirror works
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              target=target_img, speed=4*1024*1024)
         self.assert_qmp(result, 'return', {})
 
@@ -678,18 +335,18 @@ class TestSetSpeed(ImageMirroringTestCase):
     def test_set_speed_invalid(self):
         self.assert_no_active_block_jobs()
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              target=target_img, speed=-1)
-        self.assert_qmp(result, 'error/class', 'GenericError')
+        self.assert_qmp(result, 'error/class', 'OpenFileFailed')
 
         self.assert_no_active_block_jobs()
 
-        result = self.vm.qmp('drive-mirror', device='drive0', sync='full',
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
                              target=target_img)
         self.assert_qmp(result, 'return', {})
 
         result = self.vm.qmp('block-job-set-speed', device='drive0', speed=-1)
-        self.assert_qmp(result, 'error/class', 'GenericError')
+        self.assert_qmp(result, 'error/class', 'NotSupported')
 
         self.wait_ready_and_cancel()
 
@@ -709,8 +366,8 @@ class TestUnbackedSource(ImageMirroringTestCase):
 
     def test_absolute_paths_full(self):
         self.assert_no_active_block_jobs()
-        result = self.vm.qmp('drive-mirror', device='drive0',
-                             sync='full', target=target_img,
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
+                             full=True, target=target_img,
                              mode='absolute-paths')
         self.assert_qmp(result, 'return', {})
         self.complete_and_wait()
@@ -718,240 +375,12 @@ class TestUnbackedSource(ImageMirroringTestCase):
 
     def test_absolute_paths_top(self):
         self.assert_no_active_block_jobs()
-        result = self.vm.qmp('drive-mirror', device='drive0',
-                             sync='top', target=target_img,
+        result = self.vm.qmp('__com.redhat_drive-mirror', device='drive0',
+                             full=False, target=target_img,
                              mode='absolute-paths')
         self.assert_qmp(result, 'return', {})
         self.complete_and_wait()
         self.assert_no_active_block_jobs()
 
-    def test_absolute_paths_none(self):
-        self.assert_no_active_block_jobs()
-        result = self.vm.qmp('drive-mirror', device='drive0',
-                             sync='none', target=target_img,
-                             mode='absolute-paths')
-        self.assert_qmp(result, 'return', {})
-        self.complete_and_wait()
-        self.assert_no_active_block_jobs()
-
-class TestRepairQuorum(ImageMirroringTestCase):
-    """ This class test quorum file repair using drive-mirror.
-        It's mostly a fork of TestSingleDrive """
-    image_len = 1 * 1024 * 1024 # MB
-    IMAGES = [ quorum_img1, quorum_img2, quorum_img3 ]
-
-    def has_quorum(self):
-        return 'quorum' in iotests.qemu_img_pipe('--help')
-
-    def setUp(self):
-        self.vm = iotests.VM()
-
-        # Add each individual quorum images
-        for i in self.IMAGES:
-            qemu_img('create', '-f', iotests.imgfmt, i,
-                     str(TestSingleDrive.image_len))
-            # Assign a node name to each quorum image in order to manipulate
-            # them
-            opts = "node-name=img%i" % self.IMAGES.index(i)
-            self.vm = self.vm.add_drive(i, opts)
-
-        self.vm.launch()
-
-        #assemble the quorum block device from the individual files
-        args = { "options" : { "driver": "quorum", "id": "quorum0",
-                 "vote-threshold": 2, "children": [ "img0", "img1", "img2" ] } }
-        if self.has_quorum():
-            result = self.vm.qmp("blockdev-add", **args)
-            self.assert_qmp(result, 'return', {})
-
-
-    def tearDown(self):
-        self.vm.shutdown()
-        for i in self.IMAGES + [ quorum_repair_img ]:
-            # Do a try/except because the test may have deleted some images
-            try:
-                os.remove(i)
-            except OSError:
-                pass
-
-    def test_complete(self):
-        if not self.has_quorum():
-            return
-
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             node_name="repair0",
-                             replaces="img1",
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'return', {})
-
-        self.complete_and_wait(drive="quorum0")
-        result = self.vm.qmp('query-named-block-nodes')
-        self.assert_qmp(result, 'return[0]/file', quorum_repair_img)
-        # TODO: a better test requiring some QEMU infrastructure will be added
-        #       to check that this file is really driven by quorum
-        self.vm.shutdown()
-        self.assertTrue(iotests.compare_images(quorum_img2, quorum_repair_img),
-                        'target image does not match source after mirroring')
-
-    def test_cancel(self):
-        if not self.has_quorum():
-            return
-
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             node_name="repair0",
-                             replaces="img1",
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'return', {})
-
-        self.cancel_and_wait(drive="quorum0", force=True)
-        # here we check that the last registered quorum file has not been
-        # swapped out and unref
-        result = self.vm.qmp('query-named-block-nodes')
-        self.assert_qmp(result, 'return[0]/file', quorum_img3)
-        self.vm.shutdown()
-
-    def test_cancel_after_ready(self):
-        if not self.has_quorum():
-            return
-
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             node_name="repair0",
-                             replaces="img1",
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'return', {})
-
-        self.wait_ready_and_cancel(drive="quorum0")
-        result = self.vm.qmp('query-named-block-nodes')
-        # here we check that the last registered quorum file has not been
-        # swapped out and unref
-        self.assert_qmp(result, 'return[0]/file', quorum_img3)
-        self.vm.shutdown()
-        self.assertTrue(iotests.compare_images(quorum_img2, quorum_repair_img),
-                        'target image does not match source after mirroring')
-
-    def test_pause(self):
-        if not self.has_quorum():
-            return
-
-        self.assert_no_active_block_jobs()
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             node_name="repair0",
-                             replaces="img1",
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'return', {})
-
-        result = self.vm.qmp('block-job-pause', device='quorum0')
-        self.assert_qmp(result, 'return', {})
-
-        time.sleep(1)
-        result = self.vm.qmp('query-block-jobs')
-        offset = self.dictpath(result, 'return[0]/offset')
-
-        time.sleep(1)
-        result = self.vm.qmp('query-block-jobs')
-        self.assert_qmp(result, 'return[0]/offset', offset)
-
-        result = self.vm.qmp('block-job-resume', device='quorum0')
-        self.assert_qmp(result, 'return', {})
-
-        self.complete_and_wait(drive="quorum0")
-        self.vm.shutdown()
-        self.assertTrue(iotests.compare_images(quorum_img2, quorum_repair_img),
-                        'target image does not match source after mirroring')
-
-    def test_medium_not_found(self):
-        if not self.has_quorum():
-            return
-
-        result = self.vm.qmp('drive-mirror', device='ide1-cd0', sync='full',
-                             node_name='repair0',
-                             replaces='img1',
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'error/class', 'GenericError')
-
-    def test_image_not_found(self):
-        if not self.has_quorum():
-            return
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             node_name='repair0',
-                             replaces='img1',
-                             mode='existing',
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'error/class', 'GenericError')
-
-    def test_device_not_found(self):
-        if not self.has_quorum():
-            return
-
-        result = self.vm.qmp('drive-mirror', device='nonexistent', sync='full',
-                             node_name='repair0',
-                             replaces='img1',
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'error/class', 'DeviceNotFound')
-
-    def test_wrong_sync_mode(self):
-        if not self.has_quorum():
-            return
-
-        result = self.vm.qmp('drive-mirror', device='quorum0',
-                             node_name='repair0',
-                             replaces='img1',
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'error/class', 'GenericError')
-
-    def test_no_node_name(self):
-        if not self.has_quorum():
-            return
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             replaces='img1',
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'error/class', 'GenericError')
-
-    def test_unexistant_replaces(self):
-        if not self.has_quorum():
-            return
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             node_name='repair0',
-                             replaces='img77',
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'error/class', 'GenericError')
-
-    def test_after_a_quorum_snapshot(self):
-        if not self.has_quorum():
-            return
-
-        result = self.vm.qmp('blockdev-snapshot-sync', node_name='img1',
-                             snapshot_file=quorum_snapshot_file,
-                             snapshot_node_name="snap1");
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             node_name='repair0',
-                             replaces="img1",
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'error/class', 'GenericError')
-
-        result = self.vm.qmp('drive-mirror', device='quorum0', sync='full',
-                             node_name='repair0',
-                             replaces="snap1",
-                             target=quorum_repair_img, format=iotests.imgfmt)
-        self.assert_qmp(result, 'return', {})
-
-        self.complete_and_wait(drive="quorum0")
-        result = self.vm.qmp('query-named-block-nodes')
-        self.assert_qmp(result, 'return[0]/file', quorum_repair_img)
-        # TODO: a better test requiring some QEMU infrastructure will be added
-        #       to check that this file is really driven by quorum
-        self.vm.shutdown()
-
 if __name__ == '__main__':
     iotests.main(supported_fmts=['qcow2', 'qed'])
diff --git a/tests/qemu-iotests/041.out b/tests/qemu-iotests/041.out
index 24093bc..af8dac1 100644
--- a/tests/qemu-iotests/041.out
+++ b/tests/qemu-iotests/041.out
@@ -1,5 +1,5 @@
-......................................................
+............................
 ----------------------------------------------------------------------
-Ran 54 tests
+Ran 28 tests
 
 OK
-- 
1.9.3

