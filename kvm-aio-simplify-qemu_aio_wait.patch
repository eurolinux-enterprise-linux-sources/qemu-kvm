From e09386467090e722196401844e66d1f2e45a8934 Mon Sep 17 00:00:00 2001
Message-Id: <e09386467090e722196401844e66d1f2e45a8934.1427300678.git.jen@redhat.com>
In-Reply-To: <cd1e5c640073fe9f6f79125f2cbb3f434f1c7897.1427300678.git.jen@redhat.com>
References: <cd1e5c640073fe9f6f79125f2cbb3f434f1c7897.1427300678.git.jen@redhat.com>
From: Vlad Yasevich <vyasevic@redhat.com>
Date: Thu, 12 Mar 2015 19:13:00 -0500
Subject: [CHANGE 04/33] aio: simplify qemu_aio_wait
To: rhvirt-patches@redhat.com,
    jen@redhat.com

RH-Author: Vlad Yasevich <vyasevic@redhat.com>
Message-id: <1426187601-21396-5-git-send-email-vyasevic@redhat.com>
Patchwork-id: 64342
O-Subject: [RHEL6.7 qemu-kvm PATCH v2 04/25] aio: simplify qemu_aio_wait
Bugzilla: 1005016
RH-Acked-by: Michael S. Tsirkin <mst@redhat.com>
RH-Acked-by: Juan Quintela <quintela@redhat.com>
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>

From: Paolo Bonzini <pbonzini@redhat.com>

The do...while loop can never loop, because select will just not return
0 when invoked with infinite timeout.

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Signed-off-by: Kevin Wolf <kwolf@redhat.com>
(cherry picked from commit 9eb0bfca960b8cf24fb42e017c3a6479e5676f75)
Signed-off-by: Jeff E. Nelson <jen@redhat.com>

Conflicts:
	aio.c

Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
---
 aio.c | 139 ++++++++++++++++++++++++++++++++----------------------------------
 1 file changed, 67 insertions(+), 72 deletions(-)

Signed-off-by: Jeff E. Nelson <jen@redhat.com>
---
 aio.c | 125 ++++++++++++++++++++++++++++++++----------------------------------
 1 file changed, 60 insertions(+), 65 deletions(-)

diff --git a/aio.c b/aio.c
index 87dfc42..cbf0404 100644
--- a/aio.c
+++ b/aio.c
@@ -102,7 +102,11 @@ void qemu_aio_flush(void)
 
 bool qemu_aio_wait(void)
 {
+    AioHandler *node;
+    fd_set rdfds, wrfds;
+    int max_fd = -1;
     int ret;
+    bool busy;
 
     /*
      * If there are callbacks left that have been queued, we need to call then.
@@ -113,85 +117,76 @@ bool qemu_aio_wait(void)
         return true;
     }
 
-    do {
-        AioHandler *node;
-        fd_set rdfds, wrfds;
-        bool busy;
-        int max_fd = -1;
+    walking_handlers = 1;
 
-        walking_handlers++;
+    FD_ZERO(&rdfds);
+    FD_ZERO(&wrfds);
 
-        FD_ZERO(&rdfds);
-        FD_ZERO(&wrfds);
-
-        /* fill fd sets */
-        busy = false;
-        QLIST_FOREACH(node, &aio_handlers, node) {
-            /* If there aren't pending AIO operations, don't invoke callbacks.
-             * Otherwise, if there are no AIO requests, qemu_aio_wait() would
-             * wait indefinitely.
-             */
-            if (node->io_flush) {
-                if (node->io_flush(node->opaque) == 0) {
-                    continue;
-                }
-                busy = true;
-            }
-            if (!node->deleted && node->io_read) {
-                FD_SET(node->fd, &rdfds);
-                max_fd = MAX(max_fd, node->fd + 1);
-            }
-            if (!node->deleted && node->io_write) {
-                FD_SET(node->fd, &wrfds);
-                max_fd = MAX(max_fd, node->fd + 1);
+    /* fill fd sets */
+    busy = false;
+    QLIST_FOREACH(node, &aio_handlers, node) {
+        /* If there aren't pending AIO operations, don't invoke callbacks.
+         * Otherwise, if there are no AIO requests, qemu_aio_wait() would
+         * wait indefinitely.
+         */
+        if (node->io_flush) {
+            if (node->io_flush(node->opaque) == 0) {
+                continue;
             }
+            busy = true;
         }
-
-        walking_handlers--;
-
-        /* No AIO operations?  Get us out of here */
-        if (!busy) {
-            return false;
+        if (!node->deleted && node->io_read) {
+            FD_SET(node->fd, &rdfds);
+            max_fd = MAX(max_fd, node->fd + 1);
         }
+        if (!node->deleted && node->io_write) {
+            FD_SET(node->fd, &wrfds);
+            max_fd = MAX(max_fd, node->fd + 1);
+        }
+    }
 
-        /* wait until next event */
-        ret = select(max_fd, &rdfds, &wrfds, NULL, NULL);
-        if (ret == -1 && errno == EINTR)
-            continue;
+    walking_handlers = 0;
 
-        /* if we have any readable fds, dispatch event */
-        if (ret > 0) {
-            /* we have to walk very carefully in case
-             * qemu_aio_set_fd_handler is called while we're walking */
-            node = QLIST_FIRST(&aio_handlers);
-            while (node) {
-                AioHandler *tmp;
+    /* No AIO operations?  Get us out of here */
+    if (!busy) {
+        return false;
+    }
 
-                walking_handlers++;
+    /* wait until next event */
+    ret = select(max_fd, &rdfds, &wrfds, NULL, NULL);
 
-                if (!node->deleted &&
-                    FD_ISSET(node->fd, &rdfds) &&
-                    node->io_read) {
-                    node->io_read(node->opaque);
-                }
-                if (!node->deleted &&
-                    FD_ISSET(node->fd, &wrfds) &&
-                    node->io_write) {
-                    node->io_write(node->opaque);
-                }
+    /* if we have any readable fds, dispatch event */
+    if (ret > 0) {
+        walking_handlers = 1;
 
-                tmp = node;
-                node = QLIST_NEXT(node, node);
+        /* we have to walk very carefully in case
+         * qemu_aio_set_fd_handler is called while we're walking */
+        node = QLIST_FIRST(&aio_handlers);
+        while (node) {
+            AioHandler *tmp;
 
-                walking_handlers--;
+            if (!node->deleted &&
+                FD_ISSET(node->fd, &rdfds) &&
+                node->io_read) {
+                node->io_read(node->opaque);
+            }
+            if (!node->deleted &&
+                FD_ISSET(node->fd, &wrfds) &&
+                node->io_write) {
+                node->io_write(node->opaque);
+            }
 
-                if (!walking_handlers && tmp->deleted) {
-                    QLIST_REMOVE(tmp, node);
-                    qemu_free(tmp);
-                }
+            tmp = node;
+            node = QLIST_NEXT(node, node);
+
+            if (tmp->deleted) {
+                QLIST_REMOVE(tmp, node);
+                g_free(tmp);
             }
         }
-    } while (ret == 0);
+
+        walking_handlers = 0;
+    }
 
     return true;
 }
-- 
2.1.0

