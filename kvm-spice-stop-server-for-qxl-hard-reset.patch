From c29abc274cd9650b00a8bc2df5f533040b37cc2a Mon Sep 17 00:00:00 2001
From: Gerd Hoffmann <kraxel@redhat.com>
Date: Tue, 15 Jul 2014 06:50:59 -0500
Subject: [CHANGE 2/4] spice: stop server for qxl hard reset
To: rhvirt-patches@redhat.com,
    jen@redhat.com

RH-Author: Gerd Hoffmann <kraxel@redhat.com>
Message-id: <1405407061-27644-2-git-send-email-kraxel@redhat.com>
Patchwork-id: 59892
O-Subject: [RHEL-6.6 qemu-kvm PATCH 1/3] spice: stop server for qxl hard reset
Bugzilla: 995931
RH-Acked-by: Juan Quintela <quintela@redhat.com>
RH-Acked-by: Levente Kurusa <lkurusa@redhat.com>
RH-Acked-by: Dr. David Alan Gilbert (git) <dgilbert@redhat.com>

Hard reset can happen at any time.  We should be able to put qxl into a
known-good state no matter what.  Stop spice server thread for reset so
it can't be confused by fetching stale commands lingering around in the
rings while we reset is ongoing.

Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
(cherry picked from commit 75c70e37bc4a6bdc394b4d1b163fe730abb82c72)
Signed-off-by: jen <jen@redhat.com>
---
 hw/qxl.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/hw/qxl.c b/hw/qxl.c
index 0d8edeb..4970997 100644
--- a/hw/qxl.c
+++ b/hw/qxl.c
@@ -1173,8 +1173,14 @@ static void qxl_soft_reset(PCIQXLDevice *d)
 
 static void qxl_hard_reset(PCIQXLDevice *d, int loadvm)
 {
+    bool startstop = qemu_spice_display_is_running(&d->ssd);
+
     trace_qxl_hard_reset(d->id, loadvm);
 
+    if (startstop) {
+        qemu_spice_display_stop();
+    }
+
     qxl_spice_reset_cursor(d);
     qxl_spice_reset_image_cache(d);
     qxl_reset_surfaces(d);
@@ -1188,6 +1194,10 @@ static void qxl_hard_reset(PCIQXLDevice *d, int loadvm)
     }
     qemu_spice_create_host_memslot(&d->ssd);
     qxl_soft_reset(d);
+
+    if (startstop) {
+        qemu_spice_display_start();
+    }
 }
 
 static void qxl_reset_handler(DeviceState *dev)
-- 
1.9.3

