From 96e6519313362de6200ea782bef4d7a26e16cfef Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Philippe=20Mathieu-Daud=C3=A9?= <philmd@redhat.com>
Date: Fri, 5 Jul 2019 10:26:35 -0300
Subject: [PATCH 08/14] net: drop too large packet early
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

RH-Author: Philippe Mathieu-Daudé <philmd@redhat.com>
Message-id: <20190705102635.19149-5-philmd@redhat.com>
Patchwork-id: 89383
O-Subject: [RHEL-6.10.z qemu-kvm PATCH 4/4] net: drop too large packet early
Bugzilla: 1636415
RH-Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
RH-Acked-by: Stefano Garzarella <sgarzare@redhat.com>
RH-Acked-by: Xiao Wang <jasowang@redhat.com>

From: Jason Wang <jasowang@redhat.com>

We try to detect and drop too large packet (>INT_MAX) in 1592a9947036
("net: ignore packet size greater than INT_MAX") during packet
delivering. Unfortunately, this is not sufficient as we may hit
another integer overflow when trying to queue such large packet in
qemu_net_queue_append_iov():

- size of the allocation may overflow on 32bit
- packet->size is integer which may overflow even on 64bit

Fixing this by moving the check to qemu_sendv_packet_async() which is
the entrance of all networking codes and reduce the limit to
NET_BUFSIZE to be more conservative. This works since:

- For the callers that call qemu_sendv_packet_async() directly, they
  only care about if zero is returned to determine whether to prevent
  the source from producing more packets. A callback will be triggered
  if peer can accept more then source could be enabled. This is
  usually used by high speed networking implementation like virtio-net
  or netmap.
- For the callers that call qemu_sendv_packet() that calls
  qemu_sendv_packet_async() indirectly, they often ignore the return
  value. In this case qemu will just the drop packets if peer can't
  receive.

Qemu will copy the packet if it was queued. So it was safe for both
kinds of the callers to assume the packet was sent.

Since we move the check from qemu_deliver_packet_iov() to
qemu_sendv_packet_async(), it would be safer to make
qemu_deliver_packet_iov() static to prevent any external user in the
future.

This is a revised patch of CVE-2018-17963.

Cc: qemu-stable@nongnu.org
Cc: Li Qiang <liq3ea@163.com>
Fixes: 1592a9947036 ("net: ignore packet size greater than INT_MAX")
Reported-by: Li Qiang <liq3ea@gmail.com>
Reviewed-by: Li Qiang <liq3ea@gmail.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>
Reviewed-by: Thomas Huth <thuth@redhat.com>
Message-id: 20181204035347.6148-2-jasowang@redhat.com
Signed-off-by: Peter Maydell <peter.maydell@linaro.org>
(cherry picked from commit 25c01bd19d0e4b66f357618aeefda1ef7a41e21a)
[PMD: adapted net/net.c -> net.c]
Signed-off-by: Philippe Mathieu-Daudé <philmd@redhat.com>
Signed-off-by: Wainer dos Santos Moschetta <wainersm@redhat.com>
---
 net.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/net.c b/net.c
index 55bea25788..cd7d703d95 100644
--- a/net.c
+++ b/net.c
@@ -603,14 +603,9 @@ static ssize_t qemu_deliver_packet_iov(VLANClientState *sender,
                                        void *opaque)
 {
     VLANClientState *vc = opaque;
-    size_t size = iov_size(iov, iovcnt);
-
-    if (size > INT_MAX) {
-        return size;
-    }
 
     if (vc->link_down) {
-        return size;
+        return iov_size(iov, iovcnt);
     }
 
     if (vc->info->receive_iov) {
@@ -661,9 +656,14 @@ ssize_t qemu_sendv_packet_async(VLANClientState *sender,
                                 NetPacketSent *sent_cb)
 {
     NetQueue *queue;
+    size_t size = iov_size(iov, iovcnt);
+
+    if (size > NET_BUFSIZE) {
+        return size;
+    }
 
     if (sender->link_down || (!sender->peer && !sender->vlan)) {
-        return iov_size(iov, iovcnt);
+        return size;
     }
 
     if (sender->peer) {
-- 
2.13.6

