From 04e29ea8cc17bd72936b79db313de19478cdd414 Mon Sep 17 00:00:00 2001
From: Wei Huang <wei@redhat.com>
Date: Fri, 1 Mar 2019 18:15:52 -0300
Subject: [PATCH 1/2] target-i386: Sanitize the XSAVE-related feature bits

RH-Author: Wei Huang <wei@redhat.com>
Message-id: <20190301181552.24746-1-wei@redhat.com>
Patchwork-id: 84771
O-Subject: [RHEL-6.10 qemu-kvm PATCH 1/1] target-i386: Sanitize the XSAVE-related feature bits
Bugzilla: 1673779
RH-Acked-by: Bandan Das <bsd@redhat.com>
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>
RH-Acked-by: Eduardo Habkost <ehabkost@redhat.com>

BZ: https://bugzilla.redhat.com/show_bug.cgi?id=1673779
Brew: https://brewweb.engineering.redhat.com/brew/taskinfo?taskID=20416549
Upstream: No
Testing: Verified on Intel Skylake CPU with RHEL7 & RHEL8 guest VMs

On some Intel CPUs that support new XSAVE features like XSAVES, we are
seeing RHEL8 guest VM installation failure. The root cause is that QEMU
unconditionally copies XSAVE feature flags (CPUID_0xD_Leaf_0x1_EAX) from
the host CPU to the guest VM. This caused various failures because
RHEL6 doesn't support any CPU that has XSAVEC/XGETBV1/XSAVES. To solve
this problem, this patch sanitizes EAX register, only allowing XSAVEOPT,
when it is being copied.

Signed-off-by: Wei Huang <wei@redhat.com>
Signed-off-by: Wainer dos Santos Moschetta <wainersm@redhat.com>
---
 target-i386/cpu.h   | 5 +++++
 target-i386/cpuid.c | 1 +
 2 files changed, 6 insertions(+)

diff --git a/target-i386/cpu.h b/target-i386/cpu.h
index ece49dcd3c..6b48ded8f1 100644
--- a/target-i386/cpu.h
+++ b/target-i386/cpu.h
@@ -509,6 +509,11 @@
 #define CPUID_MWAIT_IBE     (1 << 1) /* Interrupts can exit capability */
 #define CPUID_MWAIT_EMX     (1 << 0) /* enumeration supported */
 
+#define CPUID_XSAVE_XSAVEOPT   (1U << 0)
+#define CPUID_XSAVE_XSAVEC     (1U << 1)
+#define CPUID_XSAVE_XGETBV1    (1U << 2)
+#define CPUID_XSAVE_XSAVES     (1U << 3)
+
 #define EXCP00_DIVZ     0
 #define EXCP01_DB       1
 #define EXCP02_NMI      2
diff --git a/target-i386/cpuid.c b/target-i386/cpuid.c
index 31149327ce..f992e836a1 100644
--- a/target-i386/cpuid.c
+++ b/target-i386/cpuid.c
@@ -1763,6 +1763,7 @@ void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
             *ebx = *ecx;
         } else if (count == 1) {
             *eax = kvm_arch_get_supported_cpuid(s, 0xd, 1, R_EAX);
+            *eax &= CPUID_XSAVE_XSAVEOPT;
         } else if (count < ARRAY_SIZE(ext_save_areas)) {
             const ExtSaveArea *esa = &ext_save_areas[count];
             if (esa->enabled(env) && kvm_mask & (1 << count)) {
-- 
2.13.6

