From 64893df2c56f59d35cdece819e617157f3ced969 Mon Sep 17 00:00:00 2001
Message-Id: <64893df2c56f59d35cdece819e617157f3ced969.1419012926.git.jen@redhat.com>
In-Reply-To: <6542ba6203e55ba5fa5a30171f9fa0690468aa33.1419012926.git.jen@redhat.com>
References: <6542ba6203e55ba5fa5a30171f9fa0690468aa33.1419012926.git.jen@redhat.com>
From: Stefan Hajnoczi <stefanha@redhat.com>
Date: Wed, 22 Oct 2014 11:48:52 -0600
Subject: [CHANGE 2/6] trace: add qemu_system_powerdown_request and
 qemu_system_shutdown_request trace events
To: rhvirt-patches@redhat.com,
    jen@redhat.com

Message-id: <1413989900-408-1-git-send-email-stefanha@redhat.com>
Patchwork-id: 61810
O-Subject: [RHEL6.7 qemu-kvm PATCH v2] trace: add qemu_system_powerdown_request and qemu_system_shutdown_request trace events
Bugzilla: 1149120
RH-Acked-by: Markus Armbruster <armbru@redhat.com>
RH-Acked-by: Fam Zheng <famz@redhat.com>
RH-Acked-by: Amos Kong <akong@redhat.com>
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>

From: Yang Zhiyong <yangzy.fnst@cn.fujitsu.com>

Bugzilla: 1149120
Brew: http://brewweb.devel.redhat.com/brew/taskinfo?taskID=8149074
Upstream: merged

We have the experience that the guest doesn't stop successfully
though it was instructed to shut down.

The root cause may be not in QEMU mostly.  However, QEMU is often
suspected at the beginning just because the issue occurred in
virtualization environment.

Therefore, we need to affirm that QEMU received the shutdown
request and raised ACPI irq from "virsh shutdown" command,
virt-manger or stopping QEMU process to the VM .
So that we can affirm the problems was belonged to the Guset OS
rather than the QEMU itself.

When we stop guests by "virsh shutdown" command or virt-manger,
or stopping QEMU process, qemu_system_powerdown_request() or
qemu_system_shutdown_request() is called. Then the below functions
in main_loop_should_exit() of Vl.c are called roughly in the
following order.

	if (qemu_powerdown_requested())
		qemu_system_powerdown()
			monitor_protocol_event(QEVENT_POWERDOWN, NULL)

	OR

	if(qemu_shutdown_requested()}
		monitor_protocol_event(QEVENT_SHUTDOWN, NULL);

The tracepoint of monitor_protocol_event() already exists, but no
tracepoints are defined for qemu_system_powerdown_request() and
qemu_system_shutdown_request(). So this patch adds two tracepoints for
the two functions. We believe that it will become much easier to
isolate the problem mentioned above by these tracepoints.

Signed-off-by: Yang Zhiyong <yangzy.fnst@cn.fujitsu.com>
Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
(cherry picked from commit bc78cff9757782501db15d39828e6af4186fe331)
Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>

Conflicts:
	trace-events
	vl.c

Both trace-events and vl.c are organized differently in RHEL6.  The
conflict is just a context conflict though and easy to resolve.

Signed-off-by: Jeff E. Nelson <jen@redhat.com>
---
 trace-events | 2 ++
 vl.c         | 2 ++
 2 files changed, 4 insertions(+)

diff --git a/trace-events b/trace-events
index f08a150..cef2752 100644
--- a/trace-events
+++ b/trace-events
@@ -186,6 +186,8 @@ disable scsi_request_sense(int target, int lun, int tag) "target %d lun %d tag %
 # vl.c
 disable vm_state_notify(int running, int reason) "running %d reason %d"
 disable runstate_set(int new_state) "new state %d"
+disable qemu_system_shutdown_request(void) ""
+disable qemu_system_powerdown_request(void) ""
 
 # block/qed-l2-cache.c
 disable qed_alloc_l2_cache_entry(void *l2_cache, void *entry) "l2_cache %p entry %p"
diff --git a/vl.c b/vl.c
index a0fb1cb..803cd0c 100644
--- a/vl.c
+++ b/vl.c
@@ -3426,12 +3426,14 @@ void qemu_system_killed(int signal, pid_t pid)
 
 void qemu_system_shutdown_request(void)
 {
+    trace_qemu_system_shutdown_request();
     shutdown_requested = 1;
     qemu_notify_event();
 }
 
 void qemu_system_powerdown_request(void)
 {
+    trace_qemu_system_powerdown_request();
     powerdown_requested = 1;
     qemu_notify_event();
 }
-- 
2.1.0

