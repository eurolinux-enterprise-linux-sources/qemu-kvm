From e445c6fbfa4c35276b2869057fdcd8e546d63a4c Mon Sep 17 00:00:00 2001
Message-Id: <e445c6fbfa4c35276b2869057fdcd8e546d63a4c.1453151886.git.jen@redhat.com>
From: =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>
Date: Tue, 22 Dec 2015 16:31:34 -0500
Subject: [CHANGE 1/8] qga: flush explicitly when needed
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
To: rhvirt-patches@redhat.com,
    jen@redhat.com

RH-Author: Marc-André Lureau <marcandre.lureau@redhat.com>
Message-id: <1450801894-29766-1-git-send-email-marcandre.lureau@redhat.com>
Patchwork-id: 68657
O-Subject: [RHEL-6.8 qemu-kvm PATCH v2] qga: flush explicitly when needed
Bugzilla: 1210246
RH-Acked-by: Thomas Huth <thuth@redhat.com>
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>
RH-Acked-by: Jeff Nelson <jenelson@redhat.com>

From: Marc-André Lureau <marcandre.lureau@redhat.com>

BZ: https://bugzilla.redhat.com/show_bug.cgi?id=1210246
Brew: http://brewweb.devel.redhat.com/brew/taskinfo?taskID=10174746
Upstream-status: 895b00f62a7e86724dc7352d67c7808d37366130

According to the specification:
http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html

"the application shall ensure that output is not directly followed by
input without an intervening call to fflush() or to a file positioning
function (fseek(), fsetpos(), or rewind()), and input is not directly
followed by output without an intervening call to a file positioning
function, unless the input operation encounters end-of-file."

Without this change, an fwrite() followed by an fread() may lose the
previously written content, as shown in the following test.

Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
Reviewed-by: Eric Blake <eblake@redhat.com>
* don't confuse {write,read}() with f{write,read}() in
  commit msg (Laszlo)
Signed-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>

(cherry picked from commit 895b00f62a7e86724dc7352d67c7808d37366130)
Signed-off-by: Jeff E. Nelson <jen@redhat.com>

Conflicts:
        qga/commands-posix.c

Straightforward conflicts due to lack of commit 77dbc81 "qga:
Consistently name Error ** objects errp, and not err".

Signed-off-by: Marc-André Lureau <marcandre.lureau@redhat.com>
Acked-by: Jeff Nelson <jenelson@redhat.com>
---
 qga/commands-posix.c | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

Signed-off-by: Jeff E. Nelson <jen@redhat.com>
---
 qga/commands-posix.c | 37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/qga/commands-posix.c b/qga/commands-posix.c
index b5d1d6c..8ee8912 100644
--- a/qga/commands-posix.c
+++ b/qga/commands-posix.c
@@ -207,9 +207,16 @@ void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp)
     }
 }
 
+typedef enum {
+    RW_STATE_NEW,
+    RW_STATE_READING,
+    RW_STATE_WRITING,
+} RwState;
+
 typedef struct GuestFileHandle {
     uint64_t id;
     FILE *fh;
+    RwState state;
     QTAILQ_ENTRY(GuestFileHandle) next;
 } GuestFileHandle;
 
@@ -457,6 +464,17 @@ struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,
     }
 
     fh = gfh->fh;
+
+    /* explicitly flush when switching from writing to reading */
+    if (gfh->state == RW_STATE_WRITING) {
+        int ret = fflush(fh);
+        if (ret == EOF) {
+            error_setg_errno(err, errno, "failed to flush file");
+            return NULL;
+        }
+        gfh->state = RW_STATE_NEW;
+    }
+
     buf = g_malloc0(count+1);
     read_count = fread(buf, 1, count, fh);
     if (ferror(fh)) {
@@ -470,6 +488,7 @@ struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,
         if (read_count) {
             read_data->buf_b64 = g_base64_encode(buf, read_count);
         }
+        gfh->state = RW_STATE_READING;
     }
     g_free(buf);
     clearerr(fh);
@@ -492,6 +511,16 @@ GuestFileWrite *qmp_guest_file_write(int64_t handle, const char *buf_b64,
     }
 
     fh = gfh->fh;
+
+    if (gfh->state == RW_STATE_READING) {
+        int ret = fseek(fh, 0, SEEK_CUR);
+        if (ret == -1) {
+            error_setg_errno(err, errno, "failed to seek file");
+            return NULL;
+        }
+        gfh->state = RW_STATE_NEW;
+    }
+
     buf = g_base64_decode(buf_b64, &buf_len);
 
     if (!has_count) {
@@ -511,6 +540,7 @@ GuestFileWrite *qmp_guest_file_write(int64_t handle, const char *buf_b64,
         write_data = g_malloc0(sizeof(GuestFileWrite));
         write_data->count = write_count;
         write_data->eof = feof(fh);
+        gfh->state = RW_STATE_WRITING;
     }
     g_free(buf);
     clearerr(fh);
@@ -534,10 +564,15 @@ struct GuestFileSeek *qmp_guest_file_seek(int64_t handle, int64_t offset,
     ret = fseek(fh, offset, whence);
     if (ret == -1) {
         error_setg_errno(err, errno, "failed to seek file");
+        if (errno == ESPIPE) {
+            /* file is non-seekable, stdio shouldn't be buffering anyways */
+            gfh->state = RW_STATE_NEW;
+        }
     } else {
         seek_data = g_malloc0(sizeof(GuestFileRead));
         seek_data->position = ftell(fh);
         seek_data->eof = feof(fh);
+        gfh->state = RW_STATE_NEW;
     }
     clearerr(fh);
 
@@ -558,6 +593,8 @@ void qmp_guest_file_flush(int64_t handle, Error **err)
     ret = fflush(fh);
     if (ret == EOF) {
         error_setg_errno(err, errno, "failed to flush file");
+    } else {
+        gfh->state = RW_STATE_NEW;
     }
 }
 
-- 
2.1.0

