From a9b3aa794a4e8acd8646db12ffc7897d7469ed9f Mon Sep 17 00:00:00 2001
Message-Id: <a9b3aa794a4e8acd8646db12ffc7897d7469ed9f.1381329939.git.minovotn@redhat.com>
In-Reply-To: <fdc2f959b4c2370865a73f9df8a0dc4e2c26d31a.1381329939.git.minovotn@redhat.com>
References: <fdc2f959b4c2370865a73f9df8a0dc4e2c26d31a.1381329939.git.minovotn@redhat.com>
From: Amit Shah <amit.shah@redhat.com>
Date: Tue, 8 Oct 2013 05:04:44 +0200
Subject: [PATCH 3/4] char: remove watch callback on chardev detach from
 frontend

RH-Author: Amit Shah <amit.shah@redhat.com>
Message-id: <0ef2e696e8e217e7c30890598dc9737d00a5ac04.1381208438.git.amit.shah@redhat.com>
Patchwork-id: 54725
O-Subject: [RHEL6.5 PATCH 3/3] char: remove watch callback on chardev detach from frontend
Bugzilla: 985205
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>
RH-Acked-by: Gerd Hoffmann <kraxel@redhat.com>
RH-Acked-by: Michael S. Tsirkin <mst@redhat.com>

If a frontend device releases the chardev (via unplug), the chr handlers
are set to NULL via qdev's exit callbacks invoking
qemu_chr_add_handlers().  If the chardev had a pending operation, a
callback will be invoked, which will try to access data in the
just-released frontend, causing a segfault.

Ensure the callbacks are disabled when frontends release chardevs.

This was seen when a virtio-serial port was unplugged when heavy
guest->host IO was in progress (causing a callback to be registered).
In the window in which the throttling was active, unplugging ports
caused a qemu segfault.

https://bugzilla.redhat.com/show_bug.cgi?id=985205

CC: <qemu-stable@nongnu.org>
Reported-by: Sibiao Luo <sluo@redhat.com>
Signed-off-by: Amit Shah <amit.shah@redhat.com>

Conflicts:
	qemu-char.c
---
 qemu-char.c | 3 +++
 1 file changed, 3 insertions(+)

Signed-off-by: Michal Novotny <minovotn@redhat.com>
---
 qemu-char.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/qemu-char.c b/qemu-char.c
index 4cfad71..2f6e914 100644
--- a/qemu-char.c
+++ b/qemu-char.c
@@ -213,6 +213,8 @@ void qemu_chr_fe_printf(CharDriverState *s, const char *fmt, ...)
     va_end(ap);
 }
 
+static void remove_fd_in_watch(CharDriverState *chr);
+
 void qemu_chr_add_handlers(CharDriverState *s,
                            IOCanReadHandler *fd_can_read,
                            IOReadHandler *fd_read,
@@ -222,6 +224,7 @@ void qemu_chr_add_handlers(CharDriverState *s,
     if (!opaque && !fd_can_read && !fd_read && !fd_event) {
         /* chr driver being released. */
         ++s->avail_connections;
+        remove_fd_in_watch(s);
     }
     s->chr_can_read = fd_can_read;
     s->chr_read = fd_read;
-- 
1.7.11.7

