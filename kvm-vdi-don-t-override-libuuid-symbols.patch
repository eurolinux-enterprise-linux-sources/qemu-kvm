From 5ff5db330f90ea75bc4f1fdafb733c35c36619ec Mon Sep 17 00:00:00 2001
Message-Id: <5ff5db330f90ea75bc4f1fdafb733c35c36619ec.1376492227.git.minovotn@redhat.com>
In-Reply-To: <276ddced7c9181cce17d0ff9eb080f99dcfe0ac3.1376492227.git.minovotn@redhat.com>
References: <276ddced7c9181cce17d0ff9eb080f99dcfe0ac3.1376492227.git.minovotn@redhat.com>
From: Asias He <asias@redhat.com>
Date: Wed, 14 Aug 2013 10:24:20 +0200
Subject: [PATCH 19/22] vdi: don't override libuuid symbols

RH-Author: Asias He <asias@redhat.com>
Message-id: <1376475863-27929-15-git-send-email-asias@redhat.com>
Patchwork-id: 53401
O-Subject: [RHEL6.5 qemu-kvm PATCH v4 14/17] vdi: don't override libuuid symbols
Bugzilla: 848070
RH-Acked-by: Kevin Wolf <kwolf@redhat.com>
RH-Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
RH-Acked-by: Jeffrey Cody <jcody@redhat.com>

From: Stefan Hajnoczi <stefanha@redhat.com>

It's poor symbol hygiene to provide a global symbols that collide with a
common library like libuuid.  If QEMU links against a shared library
that depends on uuid_generate() it can end up calling our stub version
of the function.

This exact scenario happened with GlusterFS libgfapi.so, which depends
on libglusterfs.so's uuid_generate().

Scope the uuid stubs for vdi.c only and avoid affecting other shared
objects.

Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
Reviewed-by: Kevin Wolf <kwolf@redhat.com>
(cherry picked from commit 8ba2aae32c40f544def6be7ae82be9bcb781e01d)

This patch was needed as one of the fixes to address:

   Bug 994314 - Segmentation fault in __inode_retire

Anand Avati writes:

   This bug is a combination of bad code in qemu and badly packaged qemu.
   The core of the issue is that qemu has a version of uuid_is_null() in
   block/vdi.c which is buggy (fixed upstream at
   4f3669ea5bd73ade0dce5f1155cb9ad9788fd54c). This definition of
   uuid_is_null() returns false positives as it only checked for the first
   8 bytes of the uuid to be 0s (and wrongly decided glusterfs's root gfid
   to be NULL as only the 15th byte is a 1, eventually causing it to
   wrongly retire). And this code is "enabled" in only if libuuid is not
   available in the system.

   So to fix the issue, we need to do any one (preferably both) of:

   - backport upstream commit 4f3669ea5bd73ade0dce5f1155cb9ad9788fd54c

   - install libuuid-devel in the build environment and recompile qemu

Note, libuuid-devel is added as the build dependency in this series as
well. Since the backport won't hurt, let's include it in this series too.
---
 block/vdi.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

Signed-off-by: Michal Novotny <minovotn@redhat.com>
---
 block/vdi.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/block/vdi.c b/block/vdi.c
index d3170b8..9f07f7d 100644
--- a/block/vdi.c
+++ b/block/vdi.c
@@ -59,9 +59,6 @@
 /* TODO: move uuid emulation to some central place in QEMU. */
 #include "sysemu.h"     /* UUID_FMT */
 typedef unsigned char uuid_t[16];
-void uuid_generate(uuid_t out);
-int uuid_is_null(const uuid_t uu);
-void uuid_unparse(const uuid_t uu, char *out);
 #endif
 
 /* Code configuration options. */
@@ -118,18 +115,18 @@ void uuid_unparse(const uuid_t uu, char *out);
 #define VDI_UNALLOCATED UINT32_MAX
 
 #if !defined(CONFIG_UUID)
-void uuid_generate(uuid_t out)
+static inline void uuid_generate(uuid_t out)
 {
     memset(out, 0, sizeof(uuid_t));
 }
 
-int uuid_is_null(const uuid_t uu)
+static inline int uuid_is_null(const uuid_t uu)
 {
     uuid_t null_uuid = { 0 };
     return memcmp(uu, null_uuid, sizeof(uuid_t)) == 0;
 }
 
-void uuid_unparse(const uuid_t uu, char *out)
+static inline void uuid_unparse(const uuid_t uu, char *out)
 {
     snprintf(out, 37, UUID_FMT,
             uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],
-- 
1.7.11.7

