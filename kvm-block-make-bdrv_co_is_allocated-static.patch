From 5c751085e26b123069fa1fda6bcb399eb2bd2571 Mon Sep 17 00:00:00 2001
Message-Id: <5c751085e26b123069fa1fda6bcb399eb2bd2571.1379425497.git.minovotn@redhat.com>
In-Reply-To: <f5f5558c6067d2cdb77e46707b0bda1f4f885402.1379425497.git.minovotn@redhat.com>
References: <f5f5558c6067d2cdb77e46707b0bda1f4f885402.1379425497.git.minovotn@redhat.com>
From: Paolo Bonzini <pbonzini@redhat.com>
Date: Fri, 6 Sep 2013 18:12:31 +0200
Subject: [PATCH 11/25] block: make bdrv_co_is_allocated static

bdrv_is_allocated can detect coroutine context and go through a fast
path, similar to other block layer functions.

Reviewed-by: Eric Blake <eblake@redhat.com>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
(cherry picked from commit bdad13b9deec47d5d9eaf7f43867d19a79471244)
Signed-off-by: Michal Novotny <minovotn@redhat.com>
---
 block.c        | 24 +++++++++++++++---------
 block.h        |  2 --
 block/mirror.c |  5 ++---
 block/raw.c    |  2 +-
 block/stream.c |  4 ++--
 5 files changed, 20 insertions(+), 17 deletions(-)

diff --git a/block.c b/block.c
index 39fb2e6..af28408 100644
--- a/block.c
+++ b/block.c
@@ -2167,7 +2167,7 @@ static int coroutine_fn bdrv_co_do_readv(BlockDriverState *bs,
     if (flags & BDRV_REQ_COPY_ON_READ) {
         int pnum;
 
-        ret = bdrv_co_is_allocated(bs, sector_num, nb_sectors, &pnum);
+        ret = bdrv_is_allocated(bs, sector_num, nb_sectors, &pnum);
         if (ret < 0) {
             goto out;
         }
@@ -2736,8 +2736,9 @@ typedef struct BdrvCoIsAllocatedData {
  * 'nb_sectors' is the max value 'pnum' should be set to.  If nb_sectors goes
  * beyond the end of the disk image it will be clamped.
  */
-int coroutine_fn bdrv_co_is_allocated(BlockDriverState *bs, int64_t sector_num,
-                                      int nb_sectors, int *pnum)
+static int coroutine_fn bdrv_co_is_allocated(BlockDriverState *bs,
+                                             int64_t sector_num,
+                                             int nb_sectors, int *pnum)
 {
     int64_t n;
 
@@ -2787,10 +2788,15 @@ int bdrv_is_allocated(BlockDriverState *bs, int64_t sector_num, int nb_sectors,
         .done = false,
     };
 
-    co = qemu_coroutine_create(bdrv_is_allocated_co_entry);
-    qemu_coroutine_enter(co, &data);
-    while (!data.done) {
-        qemu_aio_wait();
+    if (qemu_in_coroutine()) {
+        /* Fast-path if already in coroutine context */
+        bdrv_is_allocated_co_entry(&data);
+    } else {
+        co = qemu_coroutine_create(bdrv_is_allocated_co_entry);
+        qemu_coroutine_enter(co, &data);
+        while (!data.done) {
+            qemu_aio_wait();
+        }
     }
     return data.ret;
 }
@@ -2818,8 +2824,8 @@ int coroutine_fn bdrv_co_is_allocated_above(BlockDriverState *top,
     intermediate = top;
     while (intermediate && intermediate != base) {
         int pnum_inter;
-        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,
-                                   &pnum_inter);
+        ret = bdrv_is_allocated(intermediate, sector_num, nb_sectors,
+                                &pnum_inter);
         if (ret < 0) {
             return ret;
         } else if (ret) {
diff --git a/block.h b/block.h
index 10bc177..ac7a0df 100644
--- a/block.h
+++ b/block.h
@@ -192,8 +192,6 @@ int coroutine_fn bdrv_co_writev(BlockDriverState *bs, int64_t sector_num,
  */
 int coroutine_fn bdrv_co_write_zeroes(BlockDriverState *bs, int64_t sector_num,
     int nb_sectors);
-int coroutine_fn bdrv_co_is_allocated(BlockDriverState *bs, int64_t sector_num,
-    int nb_sectors, int *pnum);
 int coroutine_fn bdrv_co_is_allocated_above(BlockDriverState *top,
                                             BlockDriverState *base,
                                             int64_t sector_num,
diff --git a/block/mirror.c b/block/mirror.c
index 666b4ac..202089c 100644
--- a/block/mirror.c
+++ b/block/mirror.c
@@ -85,8 +85,7 @@ static int is_any_allocated(BlockDriverState *bs, int64_t sector_num,
 
     intermediate = bs;
     while (intermediate) {
-        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,
-                                   &n);
+        ret = bdrv_is_allocated(intermediate, sector_num, nb_sectors, &n);
         if (ret < 0) {
             return ret;
         } else if (ret) {
@@ -133,7 +132,7 @@ static void coroutine_fn mirror_run(void *opaque)
         if (s->full) {
             ret = is_any_allocated(bs, sector_num, next - sector_num, &n);
         } else {
-            ret = bdrv_co_is_allocated(bs, sector_num, next - sector_num, &n);
+            ret = bdrv_is_allocated(bs, sector_num, next - sector_num, &n);
         }
         if (ret < 0) {
             break;
diff --git a/block/raw.c b/block/raw.c
index d58be4b..def65e2 100644
--- a/block/raw.c
+++ b/block/raw.c
@@ -42,7 +42,7 @@ static int coroutine_fn raw_co_is_allocated(BlockDriverState *bs,
                                             int64_t sector_num,
                                             int nb_sectors, int *pnum)
 {
-    return bdrv_co_is_allocated(bs->file, sector_num, nb_sectors, pnum);
+    return bdrv_is_allocated(bs->file, sector_num, nb_sectors, pnum);
 }
 
 static int64_t raw_getlength(BlockDriverState *bs)
diff --git a/block/stream.c b/block/stream.c
index 4043d9d..ae27f11 100644
--- a/block/stream.c
+++ b/block/stream.c
@@ -139,8 +139,8 @@ wait:
             break;
         }
 
-        ret = bdrv_co_is_allocated(bs, sector_num,
-                                   STREAM_BUFFER_SIZE / BDRV_SECTOR_SIZE, &n);
+        ret = bdrv_is_allocated(bs, sector_num,
+                                STREAM_BUFFER_SIZE / BDRV_SECTOR_SIZE, &n);
         if (ret == 1) {
             /* Allocated in the top, no need to copy.  */
             copy = false;
-- 
1.7.11.7

