From 94568600ba12b8af48255b43c1eb0d8d3e6b64a4 Mon Sep 17 00:00:00 2001
From: Laszlo Ersek <lersek@redhat.com>
Date: Wed, 13 Nov 2013 23:34:45 +0100
Subject: [PATCH 30/39] hmp: human-monitor-command: stop using the Memory chardev driver

RH-Author: Laszlo Ersek <lersek@redhat.com>
Message-id: <1384385687-11423-4-git-send-email-lersek@redhat.com>
Patchwork-id: 55673
O-Subject: [RHEL-6.6 qemu-kvm PATCH 3/5] hmp: human-monitor-command: stop using the Memory chardev driver
Bugzilla: 1026903
RH-Acked-by: Markus Armbruster <armbru@redhat.com>
RH-Acked-by: Luiz Capitulino <lcapitulino@redhat.com>
RH-Acked-by: Jeffrey Cody <jcody@redhat.com>

From: Luiz Capitulino <lcapitulino@redhat.com>

The Memory chardev driver was added because, as the Monitor's output
buffer was static, we needed a way to accumulate the output of an
HMP commmand when ran by human-monitor-command.

However, the Monitor's output buffer is now dynamic, so it's possible
for the human-monitor-command to use it instead of the Memory chardev
driver.

This commit does that change, but there are two important
observations about it:

 1. We need a way to signal to the Monitor that it shouldn't call
    chardev functions when flushing its output. This is done
    by adding a new flag to the Monitor object called skip_flush
	(which is set to true by qmp_human_monitor_command())

 2. The current code has buffered semantics: QMP clients will
    only see a command's output if it flushes its output with
	a new-line character. This commit changes this to unbuffered,
	which means that QMP clients will see a command's output
	whenever the command prints anything.

	I don't think this will matter in practice though, as I believe
	all HMP commands print the new-line character anyway.

Signed-off-by: Luiz Capitulino <lcapitulino@redhat.com>
Reviewed-by: Eric Blake <eblake@redhat.com>
Acked-by: Gerd Hoffmann <kraxel@redhat.com>
(cherry picked from commit 48c043d0d1835c64b571c484a9f229fe6d220287)

Conflicts:
	monitor.c

Due to recent RHEL-6.5 fixup 9af6c67d "monitor: monitor_puts(): bail-out
when mon=NULL".

Signed-off-by: Laszlo Ersek <lersek@redhat.com>
---
 monitor.c | 15 +++++----------
 1 file changed, 5 insertions(+), 10 deletions(-)

Signed-off-by: Miroslav Rezanina <mrezanin@redhat.com>
---
 monitor.c |   15 +++++----------
 1 files changed, 5 insertions(+), 10 deletions(-)

diff --git a/monitor.c b/monitor.c
index 30eaf43..9152293 100644
--- a/monitor.c
+++ b/monitor.c
@@ -165,6 +165,7 @@ struct Monitor {
     int reset_seen;
     int flags;
     int suspend_cnt;
+    bool skip_flush;
     QString *outbuf;
     guint watch;
     ReadLineState *rs;
@@ -280,7 +281,7 @@ void monitor_flush(Monitor *mon)
     size_t len;
     const char *buf;
 
-    if (!mon) {
+    if (!mon || mon->skip_flush) {
         return;
     }
 
@@ -690,13 +691,10 @@ char *qmp_human_monitor_command(const char *command_line, bool has_cpu_index,
 {
     char *output = NULL;
     Monitor *old_mon, hmp;
-    CharDriverState mchar;
 
     memset(&hmp, 0, sizeof(hmp));
     hmp.outbuf = qstring_new();
-
-    qemu_chr_init_mem(&mchar);
-    hmp.chr = &mchar;
+    hmp.skip_flush = true;
 
     old_mon = cur_mon;
     cur_mon = &hmp;
@@ -714,17 +712,14 @@ char *qmp_human_monitor_command(const char *command_line, bool has_cpu_index,
     handle_user_command(&hmp, command_line);
     cur_mon = old_mon;
 
-    if (qemu_chr_mem_osize(hmp.chr) > 0) {
-        QString *str = qemu_chr_mem_to_qs(hmp.chr);
-        output = g_strdup(qstring_get_str(str));
-        QDECREF(str);
+    if (qstring_get_length(hmp.outbuf) > 0) {
+        output = g_strdup(qstring_get_str(hmp.outbuf));
     } else {
         output = g_strdup("");
     }
 
 out:
     QDECREF(hmp.outbuf);
-    qemu_chr_close_mem(hmp.chr);
     return output;
 }
 
-- 
1.7.1

