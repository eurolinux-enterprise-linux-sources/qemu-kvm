From 622e968e632ec270c09d155bbdd0aa5e783e2184 Mon Sep 17 00:00:00 2001
Message-Id: <622e968e632ec270c09d155bbdd0aa5e783e2184.1427148003.git.jen@redhat.com>
In-Reply-To: <b8c4fd0ae93c624609d61e4789afa7daaf50a8f1.1427148003.git.jen@redhat.com>
References: <b8c4fd0ae93c624609d61e4789afa7daaf50a8f1.1427148003.git.jen@redhat.com>
From: Gerd Hoffmann <kraxel@redhat.com>
Date: Wed, 11 Mar 2015 15:11:01 -0500
Subject: [CHANGE 7/9] vbe: make bochs dispi interface return the correct
 memory size with qxl
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
To: rhvirt-patches@redhat.com,
    jen@redhat.com

RH-Author: Gerd Hoffmann <kraxel@redhat.com>
Message-id: <1426086663-17937-8-git-send-email-kraxel@redhat.com>
Patchwork-id: 64289
O-Subject: [RHEL-6.7 qemu-kvm PATCH v4 7/9] vbe: make bochs dispi interface return the correct memory size with qxl
Bugzilla: 1053039
RH-Acked-by: Dr. David Alan Gilbert <dgilbert@redhat.com>
RH-Acked-by: Marc-Andr√© Lureau <mlureau@redhat.com>
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>

VgaState->vram_size is the size of the pci bar.  In case of qxl not the
whole pci bar can be used as vga framebuffer.  Add a new variable
vbe_size to handle that case.  By default (if unset) it equals
vram_size, but qxl can set vbe_size to something else.

This makes sure VBE_DISPI_INDEX_VIDEO_MEMORY_64K returns correct results
and sanity checks are done with the correct size too.

Cc: qemu-stable@nongnu.org
Signed-off-by: Gerd Hoffmann <kraxel@redhat.com>
Reviewed-by: Laszlo Ersek <lersek@redhat.com>
(cherry picked from commit 54a85d462447c1cb8a1638578a7fd086350b4d2d)
Signed-off-by: Jeff E. Nelson <jen@redhat.com>

Conflicts:
	hw/qxl.c
	hw/vga_int.h
---
 hw/qxl.c     | 1 +
 hw/vga.c     | 7 +++++--
 hw/vga_int.h | 1 +
 3 files changed, 7 insertions(+), 2 deletions(-)

Signed-off-by: Jeff E. Nelson <jen@redhat.com>
---
 hw/qxl.c     | 1 +
 hw/vga.c     | 7 +++++--
 hw/vga_int.h | 1 +
 3 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/hw/qxl.c b/hw/qxl.c
index c4888d0..ba4c30e 100644
--- a/hw/qxl.c
+++ b/hw/qxl.c
@@ -2074,6 +2074,7 @@ static int qxl_init_primary(PCIDevice *dev)
     qxl->id = 0;
 
     qxl_init_ramsize(qxl);
+    vga->vbe_size = qxl->vgamem_size;
     vga_common_init(vga);
     vga_init(vga);
     register_ioport_write(0x3c0, 16, 1, qxl_vga_ioport_write, vga);
diff --git a/hw/vga.c b/hw/vga.c
index 1b5425c..cb4ae18 100644
--- a/hw/vga.c
+++ b/hw/vga.c
@@ -544,7 +544,7 @@ static uint32_t vbe_ioport_read_data(void *opaque, uint32_t addr)
             val = s->vbe_regs[s->vbe_index];
         }
     } else if (s->vbe_index == VBE_DISPI_INDEX_VIDEO_MEMORY_64K) {
-        val = s->vram_size / (64 * 1024);
+        val = s->vbe_size / (64 * 1024);
     } else {
         val = 0;
     }
@@ -675,7 +675,7 @@ static void vbe_ioport_write_data(void *opaque, uint32_t addr, uint32_t val)
                     line_offset = w >> 1;
                 else
                     line_offset = w * ((s->vbe_regs[VBE_DISPI_INDEX_BPP] + 7) >> 3);
-                h = s->vram_size / line_offset;
+                h = s->vbe_size / line_offset;
                 /* XXX: support weird bochs semantics ? */
                 if (h < s->vbe_regs[VBE_DISPI_INDEX_YRES])
                     return;
@@ -2297,6 +2297,9 @@ void vga_common_init(VGACommonState *s)
         s->vram_size <<= 1;
     }
     s->vram_size_mb = s->vram_size >> 20;
+    if (!s->vbe_size) {
+        s->vbe_size = s->vram_size;
+    }
 
 #ifdef CONFIG_BOCHS_VBE
     s->is_vbe_vmstate = 1;
diff --git a/hw/vga_int.h b/hw/vga_int.h
index 1618650..c758b6e 100644
--- a/hw/vga_int.h
+++ b/hw/vga_int.h
@@ -115,6 +115,7 @@ typedef struct VGACommonState {
     uint32_t lfb_vram_mapped; /* whether 0xa0000 is mapped as ram */
     uint32_t bios_offset;
     uint32_t bios_size;
+    uint32_t vbe_size;
     uint32_t latch;
     uint8_t sr_index;
     uint8_t sr[256];
-- 
2.1.0

