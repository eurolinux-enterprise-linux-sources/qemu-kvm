From 2c23f4d08d6ce76eef417e44dabd4797390d1027 Mon Sep 17 00:00:00 2001
Message-Id: <2c23f4d08d6ce76eef417e44dabd4797390d1027.1484342411.git.ymankad@redhat.com>
In-Reply-To: <df26b13347392089e5699a6be872de7806a36a8c.1484342411.git.ymankad@redhat.com>
References: <df26b13347392089e5699a6be872de7806a36a8c.1484342411.git.ymankad@redhat.com>
From: Yash Mankad <ymankad@redhat.com>
Date: Fri, 13 Jan 2017 15:56:00 -0500
Subject: [CHANGE 6/8] Revert "qcow2: Support exact L1 table growth"
To: ymankad@redhat.com

This reverts commit f799f6e72782781aa9bb59c82f0a16e5f2a9dab8.

This is to revert Max's patch series that fix BZ#1405882 as
they did not have the 6.9 release flag set and could not be
justified as exceptions / blockers. Will be moved to 6.10.

Signed-off-by: Yash Mankad <ymankad@redhat.com>
---
 block/qcow2-cluster.c      | 25 +++++++++----------------
 block/qcow2-snapshot.c     |  2 +-
 block/qcow2.c              |  2 +-
 block/qcow2.h              |  3 +--
 tests/qemu-iotests/108     |  8 ++++----
 tests/qemu-iotests/108.out |  8 ++++----
 6 files changed, 20 insertions(+), 28 deletions(-)

diff --git a/block/qcow2-cluster.c b/block/qcow2-cluster.c
index 0f2cd31..2f337fe 100644
--- a/block/qcow2-cluster.c
+++ b/block/qcow2-cluster.c
@@ -28,8 +28,7 @@
 #include "block_int.h"
 #include "block/qcow2.h"
 
-int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,
-                        bool exact_size)
+int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size)
 {
     BDRVQcowState *s = bs->opaque;
     int new_l1_size2, ret, i;
@@ -38,20 +37,14 @@ int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,
     int64_t new_l1_table_offset, new_l1_size;
     uint8_t data[12];
 
-    if (min_size <= s->l1_size)
+    new_l1_size = s->l1_size;
+    if (min_size <= new_l1_size)
         return 0;
-
-    if (exact_size) {
-        new_l1_size = min_size;
-    } else {
-        /* Bump size up to reduce the number of times we have to grow */
-        new_l1_size = s->l1_size;
-        if (new_l1_size == 0) {
-            new_l1_size = 1;
-        }
-        while (min_size > new_l1_size) {
-            new_l1_size = (new_l1_size * 3 + 1) / 2;
-        }
+    if (new_l1_size == 0) {
+        new_l1_size = 1;
+    }
+    while (min_size > new_l1_size) {
+        new_l1_size = (new_l1_size * 3 + 1) / 2;
     }
 
     if (new_l1_size > INT_MAX / sizeof(uint64_t)) {
@@ -584,7 +577,7 @@ static int get_cluster_table(BlockDriverState *bs, uint64_t offset,
 
     l1_index = offset >> (s->l2_bits + s->cluster_bits);
     if (l1_index >= s->l1_size) {
-        ret = qcow2_grow_l1_table(bs, l1_index + 1, false);
+        ret = qcow2_grow_l1_table(bs, l1_index + 1);
         if (ret < 0) {
             return ret;
         }
diff --git a/block/qcow2-snapshot.c b/block/qcow2-snapshot.c
index 4ff5a35..224d222 100644
--- a/block/qcow2-snapshot.c
+++ b/block/qcow2-snapshot.c
@@ -415,7 +415,7 @@ int qcow2_snapshot_goto(BlockDriverState *bs, const char *snapshot_id)
      * L1 table of the snapshot. If the snapshot L1 table is smaller, the
      * current one must be padded with zeros.
      */
-    ret = qcow2_grow_l1_table(bs, sn->l1_size, true);
+    ret = qcow2_grow_l1_table(bs, sn->l1_size);
     if (ret < 0) {
         goto fail;
     }
diff --git a/block/qcow2.c b/block/qcow2.c
index 6dd9913..12df1d0 100644
--- a/block/qcow2.c
+++ b/block/qcow2.c
@@ -1020,7 +1020,7 @@ static int qcow2_truncate(BlockDriverState *bs, int64_t offset)
     }
 
     new_l1_size = size_to_l1(s, offset);
-    ret = qcow2_grow_l1_table(bs, new_l1_size, true);
+    ret = qcow2_grow_l1_table(bs, new_l1_size);
     if (ret < 0) {
         return ret;
     }
diff --git a/block/qcow2.h b/block/qcow2.h
index 70bfc06..e0b5a47 100644
--- a/block/qcow2.h
+++ b/block/qcow2.h
@@ -332,8 +332,7 @@ int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,
                                   int64_t size);
 
 /* qcow2-cluster.c functions */
-int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,
-                        bool exact_size);
+int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size);
 int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index);
 void qcow2_l2_cache_reset(BlockDriverState *bs);
 int qcow2_decompress_cluster(BlockDriverState *bs, uint64_t cluster_offset);
diff --git a/tests/qemu-iotests/108 b/tests/qemu-iotests/108
index ee127c1..ae6ec20 100755
--- a/tests/qemu-iotests/108
+++ b/tests/qemu-iotests/108
@@ -67,21 +67,21 @@ echo
 
 IMGOPTS='cluster_size=512' _make_test_img 64M
 # Allocate the first 128 kB in the image (first refblock)
-$QEMU_IO -c 'write 0 0x1b200' "$TEST_IMG" | _filter_qemu_io
+$QEMU_IO -c 'write 0 0x1a600' "$TEST_IMG" | _filter_qemu_io
 # should be 131072 == 0x20000
 stat -c '%s' "$TEST_IMG"
 
 # Enter a cluster at 128 kB (0x20000)
 # XXX: This should be the first free entry in the last L2 table, but we cannot
 # be certain
-poke_file "$TEST_IMG" $((0x1ccc8)) "\x80\x00\x00\x00\x00\x02\x00\x00"
+poke_file "$TEST_IMG" $((0x1d898)) "\x80\x00\x00\x00\x00\x02\x00\x00"
 
 # Fill the cluster
 truncate -s $((0x20200)) "$TEST_IMG"
 poke_file "$TEST_IMG" "$((128 * 1024))" "$(printf '%512s' '')"
 
 # The data should now appear at this guest offset
-$QEMU_IO -c 'read -P 32 0x1b200 512' "$TEST_IMG" | _filter_qemu_io
+$QEMU_IO -c 'read -P 32 0x1a600 512' "$TEST_IMG" | _filter_qemu_io
 
 # This cluster is unallocated; fix it
 _check_test_img -r all
@@ -89,7 +89,7 @@ _check_test_img -r all
 # This repair operation must have allocated a new refblock; and that refblock
 # should not overlap with the unallocated data cluster. If it does, the data
 # will be damaged, so check it.
-$QEMU_IO -c 'read -P 32 0x1b200 512' "$TEST_IMG" | _filter_qemu_io
+$QEMU_IO -c 'read -P 32 0x1a600 512' "$TEST_IMG" | _filter_qemu_io
 
 echo
 echo '=== Repairing refblock beyond the image end ==='
diff --git a/tests/qemu-iotests/108.out b/tests/qemu-iotests/108.out
index 5774a89..0b4e0ac 100644
--- a/tests/qemu-iotests/108.out
+++ b/tests/qemu-iotests/108.out
@@ -23,10 +23,10 @@ read 65536/65536 bytes at offset 0
 === Repairing unreferenced data cluster in new refblock area ===
 
 Formatting 'TEST_DIR/t.IMGFMT', fmt=IMGFMT size=67108864 
-wrote 111104/111104 bytes at offset 0
-108.500 KiB, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
+wrote 108032/108032 bytes at offset 0
+105.500 KiB, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
 131072
-read 512/512 bytes at offset 111104
+read 512/512 bytes at offset 108032
 512 bytes, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
 ERROR cluster 256 refcount=0 reference=1
 Rebuilding refcount structure
@@ -39,7 +39,7 @@ The following inconsistencies were found and repaired:
 
 Double checking the fixed image now...
 No errors were found on the image.
-read 512/512 bytes at offset 111104
+read 512/512 bytes at offset 108032
 512 bytes, X ops; XX:XX:XX.X (XXX YYY/sec and XXX ops/sec)
 
 === Repairing refblock beyond the image end ===
-- 
2.7.4

