From 21e709cfe469832258f7666440d4df9188b443c4 Mon Sep 17 00:00:00 2001
From: Kevin Wolf <kwolf@redhat.com>
Date: Wed, 9 Dec 2015 13:53:13 -0500
Subject: [PATCH 2/4] qcow2: Discard VM state in active L1 after creating
 snapshot

RH-Author: Kevin Wolf <kwolf@redhat.com>
Message-id: <1449669193-18282-2-git-send-email-kwolf@redhat.com>
Patchwork-id: 68525
O-Subject: [PATCH 1/1] qcow2: Discard VM state in active L1 after creating snapshot
Bugzilla: 1219908
RH-Acked-by: Jeffrey Cody <jcody@redhat.com>
RH-Acked-by: Stefan Hajnoczi <stefanha@redhat.com>
RH-Acked-by: Paolo Bonzini <pbonzini@redhat.com>

During savevm, the VM state is written to the active L1 of the image and
then a snapshot is taken. After that, the VM state isn't needed any more
in the active L1 and should be discarded. This is implemented by this
patch.

The impact of not discarding the VM state is that a snapshot can never
become smaller than any previous snapshot (because it would be padded
with old VM state), and more importantly that future savevm operations
cause unnecessary COWs (with associated flushes), which makes subsequent
snapshots much slower.

Signed-off-by: Kevin Wolf <kwolf@redhat.com>
Reviewed-by: Max Reitz <mreitz@redhat.com>
(cherry picked from commit 1ebf561c11302f4fbe4afdd82758fe053cf1d5fc)
Signed-off-by: Jeff E. Nelson <jen@redhat.com>

Conflicts:
	block/qcow2.h
        block/qcow2-snapshot.c

qcow2_discard_clusters() doesn't take a discard type in RHEL 6 yet
because it never passes discard requests to bs->file.

Signed-off-by: Kevin Wolf <kwolf@redhat.com>
---
 block/qcow2-snapshot.c | 6 ++++++
 block/qcow2.c          | 5 -----
 block/qcow2.h          | 5 +++++
 3 files changed, 11 insertions(+), 5 deletions(-)

diff --git a/block/qcow2-snapshot.c b/block/qcow2-snapshot.c
index 201e07a..224d222 100644
--- a/block/qcow2-snapshot.c
+++ b/block/qcow2-snapshot.c
@@ -374,6 +374,12 @@ int qcow2_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)
 
     g_free(old_snapshot_list);
 
+    /* The VM state isn't needed any more in the active L1 table; in fact, it
+     * hurts by causing expensive COW for the next snapshot. */
+    qcow2_discard_clusters(bs, qcow2_vm_state_offset(s),
+                           align_offset(sn->vm_state_size, s->cluster_size)
+                                >> BDRV_SECTOR_BITS);
+
 #ifdef DEBUG_ALLOC
     qcow2_check_refcounts(bs);
 #endif
diff --git a/block/qcow2.c b/block/qcow2.c
index e83e247..c56d496 100644
--- a/block/qcow2.c
+++ b/block/qcow2.c
@@ -1420,11 +1420,6 @@ static int qcow2_co_flush(BlockDriverState *bs)
     return bdrv_co_flush(bs->file);
 }
 
-static int64_t qcow2_vm_state_offset(BDRVQcowState *s)
-{
-	return (int64_t)s->l1_vm_state_index << (s->cluster_bits + s->l2_bits);
-}
-
 static int qcow2_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)
 {
     BDRVQcowState *s = bs->opaque;
diff --git a/block/qcow2.h b/block/qcow2.h
index f200d74..e0b5a47 100644
--- a/block/qcow2.h
+++ b/block/qcow2.h
@@ -280,6 +280,11 @@ static inline uint64_t qcow2_max_refcount_clusters(BDRVQcowState *s)
     return QCOW_MAX_REFTABLE_SIZE >> s->cluster_bits;
 }
 
+static inline int64_t qcow2_vm_state_offset(BDRVQcowState *s)
+{
+    return (int64_t)s->l1_vm_state_index << (s->cluster_bits + s->l2_bits);
+}
+
 static inline int qcow2_get_cluster_type(uint64_t l2_entry)
 {
     if (l2_entry & QCOW_OFLAG_COMPRESSED) {
-- 
2.1.0

