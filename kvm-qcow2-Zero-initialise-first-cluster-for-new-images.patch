From 63c19084d499a24cb6db7788e23c7d4d28947a7c Mon Sep 17 00:00:00 2001
Message-Id: <63c19084d499a24cb6db7788e23c7d4d28947a7c.1453151886.git.jen@redhat.com>
In-Reply-To: <e445c6fbfa4c35276b2869057fdcd8e546d63a4c.1453151886.git.jen@redhat.com>
References: <e445c6fbfa4c35276b2869057fdcd8e546d63a4c.1453151886.git.jen@redhat.com>
From: Kevin Wolf <kwolf@redhat.com>
Date: Mon, 11 Jan 2016 14:18:00 -0500
Subject: [CHANGE 3/8] qcow2: Zero-initialise first cluster for new images
To: rhvirt-patches@redhat.com,
    jen@redhat.com

RH-Author: Kevin Wolf <kwolf@redhat.com>
Message-id: <1452521880-19924-2-git-send-email-kwolf@redhat.com>
Patchwork-id: 68730
O-Subject: [RHEL-6.8 qemu-kvm PATCH 1/1] qcow2: Zero-initialise first cluster for new images
Bugzilla: 1223216
RH-Acked-by: Laszlo Ersek <lersek@redhat.com>
RH-Acked-by: Max Reitz <mreitz@redhat.com>
RH-Acked-by: Fam Zheng <famz@redhat.com>

Strictly speaking, this is only required for has_zero_init() == false,
but it's easy enough to just do a cluster-aligned write that is padded
with zeros after the header.

This fixes that after 'qemu-img create' header extensions are attempted
to be parsed that are really just random leftover data.

Cc: qemu-stable@nongnu.org
Signed-off-by: Kevin Wolf <kwolf@redhat.com>
Reviewed-by: Fam Zheng <famz@redhat.com>
Reviewed-by: Paolo Bonzini <pbonzini@redhat.com>
Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
(cherry picked from commit f8413b3c23b08a547ce18609acc6fae5fd04ed5c)
Signed-off-by: Jeff E. Nelson <jen@redhat.com>

Conflicts:
	block/qcow2.c

Signed-off-by: Kevin Wolf <kwolf@redhat.com>
Signed-off-by: Jeff E. Nelson <jen@redhat.com>
---
 block/qcow2.c | 30 +++++++++++++++++-------------
 1 file changed, 17 insertions(+), 13 deletions(-)

diff --git a/block/qcow2.c b/block/qcow2.c
index c56d496..12df1d0 100644
--- a/block/qcow2.c
+++ b/block/qcow2.c
@@ -1066,7 +1066,7 @@ static int qcow2_create2(const char *filename, int64_t total_size,
      * size for any qcow2 image.
      */
     BlockDriverState* bs;
-    QCowHeader header;
+    QCowHeader *header;
     uint64_t* refcount_table;
     int ret;
     QEMUOptionParameter *options = NULL;
@@ -1143,23 +1143,27 @@ static int qcow2_create2(const char *filename, int64_t total_size,
     }
 
     /* Write the header */
-    memset(&header, 0, sizeof(header));
-    header.magic = cpu_to_be32(QCOW_MAGIC);
-    header.version = cpu_to_be32(QCOW_VERSION);
-    header.cluster_bits = cpu_to_be32(cluster_bits);
-    header.size = cpu_to_be64(0);
-    header.l1_table_offset = cpu_to_be64(0);
-    header.l1_size = cpu_to_be32(0);
-    header.refcount_table_offset = cpu_to_be64(cluster_size);
-    header.refcount_table_clusters = cpu_to_be32(1);
+    QEMU_BUILD_BUG_ON((1 << MIN_CLUSTER_BITS) < sizeof(*header));
+    header = g_malloc0(cluster_size);
+    *header = (QCowHeader) {
+        .magic                      = cpu_to_be32(QCOW_MAGIC),
+        .version                    = cpu_to_be32(QCOW_VERSION),
+        .cluster_bits               = cpu_to_be32(cluster_bits),
+        .size                       = cpu_to_be64(0),
+        .l1_table_offset            = cpu_to_be64(0),
+        .l1_size                    = cpu_to_be32(0),
+        .refcount_table_offset      = cpu_to_be64(cluster_size),
+        .refcount_table_clusters    = cpu_to_be32(1),
+    };
 
     if (flags & BLOCK_FLAG_ENCRYPT) {
-        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);
+        header->crypt_method = cpu_to_be32(QCOW_CRYPT_AES);
     } else {
-        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
+        header->crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
     }
 
-    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));
+    ret = bdrv_pwrite(bs, 0, header, cluster_size);
+    g_free(header);
     if (ret < 0) {
         goto out;
     }
-- 
2.1.0

